<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>LiquidHaskell Blog</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/atom.xml" rel="self" />
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/atom.xml</id>
    <author>
        <name>Ranjit Jhala</name>
        <email>rjhala@eng.ucsd.edu</email>
    </author>
    <updated>2019-10-21T00:00:00Z</updated>
    <entry>
    <title>Liquid Types vs. Floyd-Hoare Logic</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2019/10/20/why-types.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2019/10/20/why-types.lhs</id>
    <published>false</published>
    <updated>2019-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Liquid Types vs. Floyd-Hoare Logic</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Oct 21, 2019
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/basic.html">basic</a>
              
            </div>

            <br>
			            <p>Several folks who are experts in the program verification literature have asked me some variant of the following question:</p>
<blockquote>
<p>How are <em>Liquid/Refinement</em> types different from <em>Floyd-Hoare logics</em>?</p>
</blockquote>
<p>This question always reminds me of <a href="https://yanniss.github.io/">Yannis Smaragdakis’</a> clever limerick:</p>
<blockquote>
<p>No idea is too obvious or dreary, If appropriately expressed in type theory, It’s a research advance, That no one understands, But they are all too impressed to be leery.</p>
</blockquote>
<p>That is, the above question can be rephrased as: why bother with the hassle of encoding properties in <em>types</em> when good old-fashioned <em>assertions</em>, <em>pre</em>- and <em>post</em>-conditions would do? Is it just a marketing gimmick to make readers too impressed to be leery?</p>
<h2 id="the-problem-quantifiers">The Problem: Quantifiers</h2>
<p>The main <em>algorithmic</em> problem with classical Floyd-Hoare logic is that to do useful things, you need to use <strong>universally quantified</strong> logical formulas inside invariants, pre- and post-conditions.</p>
<p>Verification then proceeds by asking SMT solvers to check <em>verification conditions</em> (VCs) over these quantified formulas. While SMT solvers are marvelous technological artifacts, and I bow to no one in my admiration of them, in reality, they work best on formulas from a narrowly defined set of <em>decidable theories</em>.</p>
<p>In particular, they are notoriously (and justifiably!) fickle when quizzed on VCs with quantifiers. Briefly, this is because even if the solver “knows” the universally quantified fact:</p>
<pre><code>forall x. P(x)</code></pre>
<p>the solver doesn’t know which particular terms <code>e1</code>, <code>e2</code> or <code>e3</code> to <strong>instantiate</strong> the fact at. That is, the solver doesn’t know which <code>P(e1)</code> or <code>P(e2)</code> or <code>P(e3)</code> it should work with to prove some given goal. At best, it can make some educated guesses, or use hints from the user, but these heuristics can turn out to be <a href="https://www.semanticscholar.org/paper/Trigger-Selection-Strategies-to-Stabilize-Program-Leino-Pit-Claudel/ca873df7c3172ab96dfc0d808e1654077c92064d">quite brittle</a> as the underlying logics are undecidable in general. To make verification predictable, we really want to ensure that the VCs remain decidable, and to do so, we must steer clear of the precipice of quantification.</p>
<h2 id="the-solution-types">The Solution: Types</h2>
<p>The great thing about types, as any devotee will tell you, is that the <em>compose</em>. Regrettably, that statement is only comprehensible to believers. I prefer to think of it differently: types <em>decompose</em>. To be precise:</p>
<blockquote>
<p><strong>Types <em>decompose</em> quantified assertions into quantifier-free refinements.</strong></p>
</blockquote>
<p>Let me make my point with some examples that show what verification looks like when using Refinement Types (as implemented in <a href="https://github.com/ucsd-progsys/liquidhaskell">LiquidHaskell</a>) vs Floyd-Hoare style contracts (as implemented in <a href="https://github.com/dafny-lang/dafny">Dafny</a>).</p>
<p>The goal of this exercise is to illustrate how types help with verification, not to compare the tools LH and Dafny. In particular, Dafny could profit from refinement types, and LH could benefit from the many clever ideas embodied within Dafny.</p>
<h2 id="example-1-properties-of-data">Example 1: Properties of Data</h2>
<p>Consider the following standard definition of a <code>List</code> datatype in Dafny (left) and LH (right).</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_1_1.png"
       height="200"> <br><b>Fig 1: </b>A list data type in Dafny (L) and LiquidHaskell (R) <br>
</div>
</div>
<p>(You can see the full definitions for <a href="https://rise4fun.com/Dafny/tkfQ">Dafny</a> and <a href="FIXME">LiquidHaskell</a>.)</p>
<h3 id="accessing-a-list">Accessing a list</h3>
<p>The two descriptions are more or less the same except for some minor issues of concrete syntax. However, next consider the respective implementations of a function to access the <code>ith</code> element of a <code>List</code>. We also pass in a <code>def</code>ault value returned when the index <code>i</code> is <em>invalid</em>.</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_1_2.png"
       height="200"> <br><b>Fig 2: </b>Accessing the i-th element of a list in Dafny(L) and LiquidHaskell(R)<br>
</div>
</div>
<p>It is (usually) silly to access lists in this fashion. I use this example merely to illustrate the common case of defining a <em>container</em> structure (here, <code>List</code>) and then <em>accessing</em> its contents (here, <code>ith</code>). As such, we’d like to <em>specify</em> that the value returned by the <code>ith</code> element is indeed in the container <em>or</em> is the <code>def</code>ault.</p>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>With classical Floyd-Hoare logic, as shown in the Dafny listing on the left, we must spell out the specification quite explicitly. The programmer must write an <code>elements</code> function that describes the <em>set</em> of values in the container, and then the <em>post-condition</em> of <code>ith</code> states that the <code>res</code> is either in that set or the default.</p>
<p>While this specification seems simple enough, we are already on dicey terrain: how are we to encode the semantics of the user-defined function <code>elements</code> to the SMT solver? In the classical Floyd-Hoare approach, we must use a <em>quantified invariant</em> of the form:</p>
<pre><code>   elements(Nil) = empty 
&amp;&amp; forall h t :: elements(Cons(h, t)) = {h} + elements(t)</code></pre>
<p>Thanks to the ingenuity of <a href="https://en.wikipedia.org/wiki/Greg_Nelson_(computer_scientist)">Greg Nelson</a> who invented the notion of <em>triggers</em> and of <a href="http://leino.science/">Rustan Leino</a> and many others, who devised ingenious heuristics for using them, Dafny handles the quantifier calmly to verify the above specification for <code>ith</code>. However, we are not always so fortunate: it frightfully easy to run into quantifier-related problems with user-defined functions, as we will see in due course.</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>In contrast, the liquid/refinement version is quite spare: there <em>is</em> no extra specification beyond the code. Surely there must be some mistake? Look again: the <em>type signature</em> says everything we need:</p>
<blockquote>
<p>If you call <code>ith</code> with a list of <code>a</code> values and a default <code>a</code> value then you will get back an <code>a</code> value".</p>
</blockquote>
<p>That is <em>parametricity</em> removes the overhead of using an explicit <code>elements</code> function.</p>
<h3 id="building-a-list">Building a list</h3>
<p>Next, lets extend our example to illustrate the common situation where we want some <em>invariant</em> to be true for <em>all</em> the values in a container. To this end, let us write a function <code>mkList</code> that <em>builds</em> a container with values <code>k+1</code>,…,<code>k+n</code> and then <em>test</em> that when <code>k</code> is non-negative, any arbitrarily chosen value from the container is indeed strictly positive.</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_1_3.png"
       height="200"> <br><b>Fig 3: </b>Building and accessing a list in Dafny (L) and LiquidHaskell(R)<br>
</div>
</div>
<p>The code in Dafny and LH is more or less the same, except for one crucial difference.</p>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>Recall that the specification for <code>ith(pos, i, 1)</code> states that the returned value is <em>some</em> element of the container (or <code>1</code>). Thus, to verify the <code>assert</code> in <code>testPosN</code> using classical Floyd-Hoare logic, we need a way to specify that <em>every</em> element in <code>pos</code> is indeed strictly positive. With classical program logics, the only way to do so is to use a <em>universally quantified</em> post-condition, highlighted in blue:</p>
<p>“<strong>for all</strong> <code>v</code> <em>if</em> <code>v</code> is in the elements of the <code>res</code>ult, <em>then</em> <code>v</code> is greater than <code>k</code>”</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>Regardless of my personal feelings about quantifiers, we can agree that the version on the right is simpler as types make it unnecessary to mention <code>elements</code> or <code>forall</code>. Instead, LH <em>infers</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">mkList <span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> k<span class="op">:</span><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">List</span> {v<span class="op">:</span><span class="dt">Int</span> <span class="op">|</span> k <span class="op">&lt;</span> v}</a></code></pre></div>
<p>That is, that the output type of <code>mkList</code> is a list of values <code>v</code> that are all greater than <code>k</code>. The scary <em>forall</em> has been replaced by the friendly <em>type constructor</em> <code>List</code>. In other words, types allow us to <em>decompose</em> the monolithic universally quantified invariant into:</p>
<ol type="1">
<li>a <em>quantifier-free</em> refinement <code>k &lt; v</code>, and</li>
<li>a type <em>constructor</em> that implicitly “quantifies” over the container’s elements.</li>
</ol>
<h3 id="lesson-decomposition-enables-inference">Lesson: Decomposition Enables Inference</h3>
<p>Am I cheating? After all, what prevents Dafny from <em>inferring</em> the same post-condition as LH?</p>
<p>Once again, quantifiers are the villain.</p>
<p>There have been many decades worth of papers on the topic of inferring quantified invariants, but save some nicely circumscribed use-cases these methods turn out to be rather difficult to get working efficiently and predictably enough to be practical. In contrast, once the quantifiers are decomposed away, even an extremely basic approach called <a href="http://www-verimag.imag.fr/~graf/PAPERS/GrafSaidi97.pdf">Monomial Predicate Abstraction</a>, or more snappily, <a href="https://dl.acm.org/citation.cfm?id=730008">Houdini</a>, suffices to infer the above liquid type.</p>
<h2 id="example-2-properties-of-structures">Example 2: Properties of Structures</h2>
<p>Recall that when discussing the user-defined <code>elements</code> function above, I had issued some dark warnings about quantifier-related problems that arise from user-defined functions. Allow me to explain with another simple example, that continues with the <code>List</code> datatype defined above.</p>
<p>(You can see the full definitions for <a href="https://rise4fun.com/Dafny/nphIv">Dafny</a> and <a href="FIXME">LiquidHaskell</a>.)</p>
<h3 id="specifying-a-size-function">Specifying a <code>size</code> Function</h3>
<p>Lets write the usual <em>recursive</em> function that computes the <code>size</code> of a list. The definitions are mostly identical, except for the green <code>measure</code> highlight that we will discuss below.</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_2_1.png"
       height="200"> <br><b>Fig 4: </b>A function defining the size of a list in Dafny (L) and LiquidHaskell (R)<br>
</div>
</div>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>SMT solvers are restricted to a set of <em>ground</em> theories and hence, do not “natively” understand user-defined functions. Instead, the verifer must <em>teach</em> the SMT solver how to reason about formulas (VCs) containing uses of user-defined functions like <code>size</code>. In the classical Floyd-Hoare approach, this is done by converting the definition of <code>size</code> into a universally quantified <em>axiom</em> like:</p>
<pre><code>size Nil == 0  &amp;&amp; forall h, t :: size (Cons h t) = 1 + size t</code></pre>
<p>A quantifier! By the pricking of my thumbs, something wicked this way comes…</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>With a more <em>type-centric</em> view, we can think of the recursive function <code>size</code> as a way to <em>decorate</em> or <em>refine</em> the types of the <em>data constructors</em>. So, when you write the definition in the green box above, specifically when you add the <code>measure</code> annotation, the function is converted to <em>strengthened</em> versions for the types of the constructors <code>Nil</code> and <code>Cons</code>, so its as if we had defined the list type as two constructor functions</p>
<pre><code>data List a where
  Cons :: h:a -&gt; t:List a -&gt; {v:List a | size v == 1 + size t}
  Nil  :: {v:List a | size v == 0} </code></pre>
<p>That is, the bodies of the measures get translated to refinements on the output types of the corresponding constructors. After this, the SMT solver “knows nothing” about the semantics of <code>size</code>, except that it is a function. In logic-speak, <code>size</code> is <strong>uninterpreted</strong> in the refinement, and there are no quantified axioms. That is, we choose to keep SMT solver blissfully ignorant about the semantics of <code>size</code>. How could this possibly be a good thing?</p>
<h3 id="verifying-the-size-of-a-list">Verifying the <code>size</code> of a List</h3>
<p>Next, lets see what happens when we write a simple test that builds a small list with two elements and <code>assert</code>s that the lists <code>size</code> is indeed <code>2</code>:</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_2_2.png"
       height="200"> <br><b>Fig 5: </b>Verifying the size of a list in Dafny (L) and LiquidHaskell (R)<br>
</div>
</div>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>To get Dafny to verifier to sign off on the <code>assert (size(pos) == 2)</code> we have to add a mysterious <em>extra assertion</em> that checks the size of the intermediate value <code>Cons (1, Nil)</code>. (Without it, verification fails.)</p>
<p>Huh? Pesky quantifiers.</p>
<p>The SMT solver doesn’t know <em>where</em> to instantiate the <code>size</code> axom. In this carefully chosen, but nevertheless simple situation, Dafny’s instantiation heuristics come up short. I had to help them along by guessing this intermediate assertion, which effectively “adds” the fact that the size of the intermediate list is 1, thereby letting the SMT solver prove the second assertion.</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>In contrast, with types, the solver is able to verify the code without batting an eyelid. But how could it possibly do so even though we kept it ignorant of the semantics of <code>size</code>?</p>
<p>Because types decompose reasoning. In particular, here, the measure and constructor trick lets us <em>factor reasoning about <code>size</code> into the type system</em>.</p>
<p>In particular, LH internally views the code for <code>test</code> in A-Normal Form which is a fancy way of saying, by introducing temporary variables for all sub-expressions:</p>
<pre><code>test x1 = 
   let tmp0 = Nil                
       tmp1 = Cons x1 tmp0 
       pos  = Cons  0 tmp1
   in 
      assert (size pos == 2)</code></pre>
<p>And now, just by the rules of type checking, and applying the types of the constructors, it deduces that:</p>
<pre><code>   tmp0 :: {size tmp0 == 0}
   tmp1 :: {size tmp1 == 1 + size tmp0}
   pos  :: {size pos  == 1 + size tmp1}</code></pre>
<p>which lets the SMT solver prove that <code>size pos == 2</code> without requiring any axiomatic description of <code>size</code>. This simple <code>measure</code> method goes a very long way in specifying and verifying <a href="http://goto.ucsd.edu/~rjhala/papers/real_world_liquid.pdf">lots of properties</a>.</p>
<h3 id="lesson-decomposition-enables-type-directed-instantiation">Lesson: Decomposition Enables Type-Directed Instantiation</h3>
<p>I’d like to emphasize again that this trick was enabled by the type-centric view: encode the function semantics in <em>data constructors</em>, and let the type checking (or VC generation) do the <em>instantiation</em>.</p>
<p>It could easily by incorporated inside and work together with axioms in Floyd-Hoare based systems like Dafny. Of course, this approach is limited to a restricted class of functions – roughly, case-splits over a single data type’s constructors – but we can generalize the method quite a bit using the idea of <a href="https://arxiv.org/abs/1711.03842">logical evaluation</a>.</p>
<h2 id="summary">Summary</h2>
<p>To sum up, we saw two examples where taking a type-centric view made verification more <em>ergonomic</em>, essentially by <em>factoring</em> reasoning about quantifiers into the type system.</p>
<ul>
<li><p>In the first case, when reasoning about <em>data</em> in containers, the polymorphic type constructor <code>List</code> provided an natural way to reason about the fact that <em>all</em> elements in a container satisfied some property.</p></li>
<li><p>In the second case, when reasoning about the <em>structure</em> of the container via a recursive function, the types of the data constructors allowed us to factor the instantiation of properties of <code>size</code> at places where the list was constructed (and dually, not shown, destructed) without burdening the SMT solver with any axioms and the pressure of figuring out where to instantiate them.</p></li>
</ul>
<p>As you might imagine, the benefits are even more pronounced when working with higher-order functions, e.g. <code>map</code>-ing or <code>fold</code>-ing over containers…</p>
<h3 id="acknowledgments">Acknowledgments</h3>
<p>Huge thanks to <a href="http://leino.science/">Rustan Leino</a>, <a href="https://cseweb.ucsd.edu/~npolikarpova/">Nadia Polikarpova</a>, <a href="http://cseweb.ucsd.edu/~daricket/">Daniel Ricketts</a>, <a href="https://twitter.com/hillelogram">Hillel Wayne</a>, and <a href="https://twitter.com/zizzivon">Zizz Vonnegut</a> for patiently answering my many questions about Dafny!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2019/10/20/why-types.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2019/10/20/why-types.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>The Hillelogram Verifier Rodeo I (LeftPad)</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs</id>
    <published>true</published>
    <updated>2018-05-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>The Hillelogram Verifier Rodeo I (LeftPad)</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			May 17, 2018
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/reflection.html">reflection</a>
              
            </div>

            <br>
			            <!--
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">You have to provide a 100%, machine-checked guarantee that there are no problems with your code whatsoever. If it&#39;s so much easier to analyze FP programs than imperative programs, this should be simple, right?</p>&mdash; Hillel (@Hillelogram) <a href="https://twitter.com/Hillelogram/status/987432180837167104?ref_src=twsrc%5Etfw">April 20, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
-->
<p>A month ago, <a href="https://twitter.com/Hillelogram">Hillel Wayne</a> posted a <a href="https://twitter.com/Hillelogram/status/987432180837167104">verification challenge</a> comprising three problems that might <em>sound</em> frivolous, but which, in fact, hit the sweet spot of being easy to describe and yet interesting to implement and verify. I had a lot of fun hacking them up in LH, and learned some things doing so.</p>
<p>Today, lets see how to implement the first of these challenges – <code>leftPad</code> – in Haskell, and to check Hillel’s specification with LH.</p>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=LeftPad.hs">demo</a>)</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>35: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--reflection"</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>36: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--ple"</span>         <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>37: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infixr</span> <span class='hs-varop'>++</span>              <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>38: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infixr</span> <span class='hs-varop'>!!</span>              <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>39: </span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>PadLeft</span> <span class='hs-keyword'>where</span> 
<span class=hs-linenum>41: </span>
<span class=hs-linenum>42: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>max</span><span class='hs-layout'>,</span> <span class='hs-varid'>replicate</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>43: </span><span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>44: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>45: </span><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>46: </span><span class='hs-definition'>obviously</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>47: </span><span class='hs-definition'>replicate</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>48: </span><span class='hs-definition'>thmReplicate</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>thmAppLeft</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>50: </span><span class='hs-definition'>thmAppRight</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>51: </span><span class='hs-definition'>thmLeftPad</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>52: </span>
<span class=hs-linenum>53: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>max</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>54: </span><span class='hs-definition'>max</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>55: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : GHC.Types.Int | VV == max x1 x2
                                                              &amp;&amp; VV == (if x1 &gt; x2 then x1 else x2)}</span><span class='hs-definition'>max</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; x &gt; y}</span><span class='hs-keyword'>if</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; x &gt; y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &gt; x2}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>y</span> 
<span class=hs-linenum>56: </span>
<span class=hs-linenum>57: </span><span class='hs-comment'>-- A ghost function only used in the specification</span>
<span class=hs-linenum>58: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftPadVal</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int | False}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span>
</pre>
</div>
<h2 id="the-leftpad-challenge">The LeftPad Challenge</h2>
<p>The first of these problems was <a href="https://twitter.com/Hillelogram/status/987432181889994759">leftPad</a></p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
<ol type="1">
<li>Leftpad. Takes a padding character, a string, and a total length, returns the string padded with that length with that character. If length is less than string, does nothing.<a href="https://t.co/X8qR8gTZdO">https://t.co/X8qR8gTZdO</a>
</p>
— Hillel (<span class="citation" data-cites="Hillelogram">@Hillelogram</span>) <a href="https://twitter.com/Hillelogram/status/987432181889994759?ref_src=twsrc%5Etfw">April 20, 2018</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></li>
</ol>
<h2 id="implementation">Implementation</h2>
<p>First, lets write an idiomatic implementation of <code>leftPad</code> where we will take the liberty of generalizing</p>
<ul>
<li>the <strong>padding character</strong> to be the input <code>c</code> that is of some (polymorphic) type <code>a</code></li>
<li>the <strong>string</strong> to be the input <code>xs</code> that is a list of <code>a</code></li>
</ul>
<p>If the target length <code>n</code> is indeed greater than the input string <code>xs</code>, i.e. if <code>k = n - size xs</code> is positive, we <code>replicate</code> the character <code>c</code> <code>k</code> times and append the result to the left of the input <code>xs</code>. Otherwise, if <code>k</code> is negative, we do nothing, i.e. return the input.</p>
<pre><span class=hs-linenum>87: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>leftPad</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>88: </span><span class='hs-definition'>leftPad</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>89: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; a -&gt; x3:[a] -&gt; {res : [a] | size res == max x1 (size x3)}</span><span class='hs-definition'>leftPad</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> 
<span class=hs-linenum>90: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>k</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:a -&gt; {v : [a] | size v == k
                        &amp;&amp; v == replicate k x1
                        &amp;&amp; v == (if 0 == k then [] else : x1 (replicate (k - 1) x1))} | v == replicate k}</span><span class='hs-varid'>replicate</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>c</span> <span class='hs-varop'>++</span> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>91: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>92: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>93: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>size</span></a> <span class='hs-varid'>xs</span>
</pre>
<p>The code for <code>leftPad</code> is short because we’ve delegated much of the work to <code>size</code>, <code>replicate</code> and <code>++</code>. Here’s how we can compute the <code>size</code> of a list:</p>
<pre><span class=hs-linenum>101: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>size</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>102: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>103: </span><a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0
                               &amp;&amp; v == size x1}</span><span class='hs-definition'>size</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> 
<span class=hs-linenum>104: </span><span class='hs-definition'>size</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1 : int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>size</span></a> <span class='hs-varid'>xs</span>
</pre>
<p>and here is the list append function <code>++</code> :</p>
<pre><span class=hs-linenum>110: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>++</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>111: </span><span class='hs-keyword'>{-@</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>112: </span>            <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| size v = size xs + size ys}</span> 
<span class=hs-linenum>113: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>114: </span><span class='hs-conid'>[]</span>     <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; {v : [a] | size v == size x1 + size x2}</span><span class='hs-varop'>++</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span> 
<span class=hs-linenum>115: </span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [a] | size v == size xs + size ys
           &amp;&amp; v == ++ xs ys}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
</pre>
<p>and finally the implementation of <code>replicate</code> :</p>
<pre><span class=hs-linenum>121: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>replicate</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>122: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>replicate</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>123: </span>                 <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| size v = n}</span> 
<span class=hs-linenum>124: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>125: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; a -&gt; {v : [a] | size v == x1}</span><span class='hs-definition'>replicate</span></a> <span class='hs-num'>0</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> 
<span class=hs-linenum>126: </span><span class='hs-definition'>replicate</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; a -&gt; {v : [a] | size v == x1}</span><span class='hs-varid'>replicate</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span>
</pre>
<h2 id="what-shall-we-prove">What shall we Prove?</h2>
<p>My eyes roll whenever I read the phrase “proved X (a function, a program) <em>correct</em>”.</p>
<p>There is no such thing as “correct”.</p>
<p>There are only “specifications” or “properties”, and proofs that ensures that your code matches those specifications or properties.</p>
<p>What <em>specifications</em> shall we verify about our implementation of <code>leftPad</code>? One might argue that the above code is “obviously correct”, i.e. the implementation more or less directly matches the informal requirements.</p>
<p>One way to formalize this notion of “obviously correct” is to verify a specification that directly captures the informal requirements:</p>
<pre><span class=hs-linenum>151: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>obviously</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>152: </span>      <span class='hs-keyword'>{ leftPad n c xs = if (size xs &lt; n) 
                         then (replicate (n - size xs) c ++ xs) 
                         else xs }</span> 
<span class=hs-linenum>155: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>156: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:a -&gt; x3:[a] -&gt; {VV : () | leftPad x1 x2 x3 == (if size x3 &lt; x1 then ++ (replicate (x1 - size x3) x2) x3 else x3)}</span><span class='hs-definition'>obviously</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>In the above, the type signature is a specification that says that for all <code>n</code>, <code>c</code> and <code>xs</code>, the value returned by <code>leftPad n c xs</code> is <code>xs</code> when <code>n</code> is too small, and the suitably padded definition otherwise.</p>
<p>The code, namely <code>()</code>, is the proof. LH is able to trivially check that <code>leftPad</code> meets the “obviously correct” specification, because, well, in this case, the implementation <em>is</em> the specification. (Incidentally, this is also why the <a href="https://github.com/hwayne/lets-prove-leftpad/blob/master/idris/Leftpad.idr">Idris solution</a> is terse.)</p>
<p>So, if you are happy with the above specification, you can stop reading right here: we’re done.</p>
<h2 id="hillels-specifications">Hillel’s Specifications</h2>
<p>However, the verification rodeo is made more interesting by Hillel’s <a href="https://rise4fun.com/Dafny/nbNTl">Dafny specifications</a>:</p>
<ol type="1">
<li><p><strong>Size</strong> The <code>size</code> of the returned sequence is the larger of <code>n</code> and the size of <code>xs</code>;</p></li>
<li><p><strong>Pad-Value</strong> Let <code>K = n - size xs</code>. We require that the <code>i</code>-th element of the padded-sequence is <code>c</code> if <code>0 &lt;= i &lt; K</code>, and is the <code>i - K</code>-th element of <code>xs</code> otherwise.</p></li>
</ol>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/leftpad-spec.png"
       alt="Ribbons" height="150">
</div>
</div>
<h2 id="digression-the-importance-of-being-decidable">Digression: The Importance of being Decidable</h2>
<p>LH, like many of the other rodeo entries, uses SMT solvers to automate verification. For example, the <code>leftPad</code> solutions in <a href="https://rise4fun.com/Dafny/nbNTl">Dafny</a> and <a href="https://blog.adacore.com/taking-on-a-challenge-in-spark">SPARK</a> and <a href="https://gist.github.com/graydon/901f98049d05db65d9a50f741c7f7626">F*</a> make heavy use <a href="https://github.com/Microsoft/dafny/blob/master/Binaries/DafnyPrelude.bpl#L898-L1110">quantified axioms to encode properties of sequences.</a></p>
<p>However, unlike its many SMT-based brethren, LH takes a somewhat fanatical stance: it <em>never</em> uses quantifiers or axioms. We take this rigid position because SMT solvers are only <em>predictable</em> on queries from (certain) <strong>decidable logics</strong>. Axioms, or more generally, quantified formulas rapidly take SMT solvers out of this “comfort zone”, causing them to reject valid formulas, run slowly, or even, <a href="https://twitter.com/johnregehr/status/996901816842440704">to run forever</a>.</p>
<!--
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I mean, I&#39;m somewhat kind of serious here, I think unneeded generality makes things really difficult often. as a random example quantifiers seem to throw z3 into a really bad place, even when they&#39;re easy ones.</p>&mdash; John Regehr (@johnregehr) <a href="https://twitter.com/johnregehr/status/996901816842440704?ref_src=twsrc%5Etfw">May 16, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<div class="row-fluid">
  <div class="span12 pagination-centered">
  <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/regehr-tweet-quantifiers.png"
       alt="Ribbons" height="100">
  </div>
</div>
-->
<p>Thus, we have chosen to deliberately avoid the siren song of quantifiers by lashing LH firmly to the steady mast of decidable logics.</p>
<h2 id="reasoning-about-sequences">Reasoning about Sequences</h2>
<p>Unfortunately, this design choice leaves us with some work: we must develop i.e. <em>state</em> and <em>prove</em> relevant properties about sequences from scratch.</p>
<p><strong>Indexing into a Sequence</strong></p>
<p>To start, lets define the notion of the <code>i</code>-th element of a sequence (this is pretty much Haskell’s list-index operator)</p>
<pre><span class=hs-linenum>247: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>!!</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>248: </span><span class='hs-keyword'>{-@</span> <span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{n:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| n &lt; size xs}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>249: </span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0
                               &amp;&amp; v &lt; size x1} -&gt; a</span><span class='hs-varop'>!!</span></a> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> 
<span class=hs-linenum>250: </span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>!!</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0
                               &amp;&amp; v &lt; size x1} -&gt; a</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
</pre>
<p><strong>Replicated Sequences</strong></p>
<p>Next, we verify that <em>every</em> element in a <code>replicate</code>-d sequence is the element being cloned:</p>
<pre><span class=hs-linenum>259: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmReplicate</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | i &lt; n}</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>260: </span>                    <span class='hs-keyword'>{ replicate n c !! i  == c }</span> 
<span class=hs-linenum>261: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>262: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:a -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                                                   &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (replicate x1 x2) x3 == x2}</span><span class='hs-definition'>thmReplicate</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v &lt; n}</span><span class='hs-varid'>i</span></a> 
<span class=hs-linenum>263: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>264: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:a -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                                                   &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (replicate x1 x2) x3 == x2}</span><span class='hs-varid'>thmReplicate</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> 
</pre>
<p>LH verifies the above “proof by induction”:</p>
<ul>
<li><p>In the base case <code>i == 0</code> and the value returned is <code>c</code> by the definition of <code>replicate</code> and <code>!!</code>.</p></li>
<li><p>In the inductive case, <code>replicate n c !! i</code> is equal to <code>replicate (n-1) c !! (i-1)</code> which, by the “induction hypothesis” (i.e. by recursively calling the theorem) is <code>c</code>.</p></li>
</ul>
<p><strong>Concatenating Sequences</strong></p>
<p>Finally, we need two properties that relate concatenation and appending, namely, the <code>i</code>-th element of <code>xs ++ ys</code> is:</p>
<ul>
<li><strong>Left</strong> the <code>i</code>-th element of <code>xs</code> if <code>0 &lt;= i &lt; size xs</code>, and</li>
<li><strong>Right</strong> the <code>i - size xs</code> element of <code>ys</code> otherwise.</li>
</ul>
<pre><span class=hs-linenum>286: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmAppLeft</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| i &lt; size xs}</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>287: </span>                  <span class='hs-keyword'>{ (xs ++ ys) !! i == xs !! i }</span> 
<span class=hs-linenum>288: </span>  <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>289: </span><a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; v &lt; size x1} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x1 x3}</span><span class='hs-definition'>thmAppLeft</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>290: </span><span class='hs-definition'>thmAppLeft</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; v &lt; size x1} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x1 x3}</span><span class='hs-varid'>thmAppLeft</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>      
<span class=hs-linenum>291: </span>
<span class=hs-linenum>292: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmAppRight</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| size xs &lt;= i}</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>293: </span>                   <span class='hs-keyword'>{ (xs ++ ys) !! i == ys !! (i - size xs) }</span> 
<span class=hs-linenum>294: </span>  <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>295: </span><a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; size x1 &lt;= v} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x2 (x3 - size x1)}</span><span class='hs-definition'>thmAppRight</span></a> <span class='hs-conid'>[]</span>     <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>296: </span><span class='hs-definition'>thmAppRight</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; size x1 &lt;= v} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x2 (x3 - size x1)}</span><span class='hs-varid'>thmAppRight</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>      
</pre>
<p>Both of the above properties are proved by induction on <code>i</code>.</p>
<h2 id="proving-hillels-specifications">Proving Hillel’s Specifications</h2>
<p>Finally, we’re ready to state and prove Hillel’s specifications.</p>
<p><strong>Size Specification</strong></p>
<p>The size specification is straightforward, in that LH proves it automatically, when type-checking <code>leftPad</code> against the signature:</p>
<pre><span class=hs-linenum>313: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftPad</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>314: </span>                <span class='hs-keyword'>{res:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| size res = max n (size xs)}</span> 
<span class=hs-linenum>315: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p><strong>Pad-Value Specification</strong></p>
<p>We <em>specify</em> the pad-value property – i.e. the <code>i</code>-th element equals <code>c</code> or the corresponding element of <code>xs</code> – by a type signature:</p>
<pre><span class=hs-linenum>325: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmLeftPad</span> 
<span class=hs-linenum>326: </span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyword'>{size xs &lt; n}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | i &lt; n}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>327: </span>         <span class='hs-keyword'>{ leftPad n c xs !! i ==  leftPadVal n c xs i }</span>                               
<span class=hs-linenum>328: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>329: </span>
<span class=hs-linenum>330: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>leftPadVal</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>331: </span><a class=annot href="#"><span class=annottext>{n : GHC.Types.Int | False} -&gt; a -&gt; [a] -&gt; GHC.Types.Int -&gt; a</span><span class='hs-definition'>leftPadVal</span></a> <a class=annot href="#"><span class=annottext>{n : GHC.Types.Int | False}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a> 
<span class=hs-linenum>332: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; i &lt; k}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>k</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> 
<span class=hs-linenum>333: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | size v &gt;= 0
           &amp;&amp; len v &gt;= 0
           &amp;&amp; v == xs}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == i - k}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>
<span class=hs-linenum>334: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-varid'>size</span> <span class='hs-varid'>xs</span> 
</pre>
<p><strong>Pad-Value Verification</strong></p>
<p>We <em>verify</em> the above property by filling in the implementation of <code>thmLeftPad</code> as:</p>
<pre><span class=hs-linenum>343: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:a -&gt; x3:{v : [a] | size v &lt; x1} -&gt; x4:{v : GHC.Types.Int | v &gt;= 0
                                                                                  &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (leftPad x1 x2 x3) x4 == leftPadVal x1 x2 x3 x4}</span><span class='hs-definition'>thmLeftPad</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | size v &lt; n}</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v &lt; n}</span><span class='hs-varid'>i</span></a> 
<span class=hs-linenum>344: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; i &lt; k}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>k</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                  &amp;&amp; v &lt; size cs} -&gt; {v : () | !! (++ cs x1) x2 == !! cs x2}</span><span class='hs-varid'>thmAppLeft</span></a>  <span class='hs-varid'>cs</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>i</span> <span class='hs-varop'>`seq`</span> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                &amp;&amp; v &lt; k} -&gt; {v : () | !! (replicate k x1) x2 == x1}</span><span class='hs-varid'>thmReplicate</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>c</span> <span class='hs-varid'>i</span>   
<span class=hs-linenum>345: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                  &amp;&amp; size cs &lt;= v} -&gt; {v : () | !! (++ cs x1) x2 == !! x1 (x2 - size cs)}</span><span class='hs-varid'>thmAppRight</span></a> <span class='hs-varid'>cs</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>i</span>
<span class=hs-linenum>346: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>347: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>size</span></a> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>348: </span>    <a class=annot href="#"><span class=annottext>{v : [a] | size v == k
           &amp;&amp; v == replicate k c
           &amp;&amp; v == (if 0 == k then [] else : c (replicate (k - 1) c))}</span><span class='hs-varid'>cs</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:a -&gt; {v : [a] | size v == k
                        &amp;&amp; v == replicate k x1
                        &amp;&amp; v == (if 0 == k then [] else : x1 (replicate (k - 1) x1))} | v == replicate k}</span><span class='hs-varid'>replicate</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>c</span>
</pre>
<p>The “proof” – in quotes because its just a Haskell function – simply combines the replicate- and concatenate-left theorems if <code>i</code> is in the “pad”, and the concatenate-right theorem, otherwise.</p>
<h2 id="conclusions">Conclusions</h2>
<p>That concludes part I of the rodeo. What did I learn from this exercise?</p>
<ol type="1">
<li><p>Even apparently simple functions like <code>leftPad</code> can have <em>many</em> different specifications; there is no necessarily “best” specification as different specs make different assumptions about what is “trusted”, and more importantly, though we didn’t see it here, ultimately a spec is a particular <em>view</em> into how a piece of code behaves and we may want different views depending on the context where we want to use the given piece of code.</p></li>
<li><p>The <code>leftPad</code> exercise illustrates a fundamental problem with Floyd-Hoare style “modular” verification, where pre- and post-conditions (or contracts or refinement types or …) are used to modularly “abstract” functions i.e. are used to describe the behavior of a function at a call-site. As the above exercise shows, we often need properties connecting the behavior of different functions, e.g. append (<code>++</code>), indexing (<code>!!</code>). In these cases, the only meaningful <em>specification</em> for the underlying function <em>is its implementation</em>.</p></li>
<li><p>Finally, the above proofs are all over user-defined recursive functions which this was not even possible before <a href="/tags/reflection.html">refinement reflection</a>, i.e till about a year ago. I’m also quite pleased by how <a href="/tags/ple.html">logical evaluation</a> makes these proofs quite short, letting LH verify expressive specifications while steering clear of the siren song of quantifiers.</p></li>
</ol>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Measures and Case Splitting</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2018/02/23/measures-and-case-splitting.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2018/02/23/measures-and-case-splitting.lhs</id>
    <published>true</published>
    <updated>2018-02-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Measures and Case Splitting</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Feb 23, 2018
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/measures.html">measures</a>, <a href="/tags/advanced.html">advanced</a>
              
            </div>

            <br>
			            <p>Liquid Haskell has a flag called <code>--no-case-expand</code> which can make verification of your code much faster, especially when your code is using ADTs with many alternatives. This flag says relax precision to get fast verification, thus may lead to rejecting safe code.</p>
<p>In this post, I explain how <code>--no-case-expand</code> works using a trivial example!</p>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=RangeSet.hs">demo</a>)</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>28: </span>
<span class=hs-linenum>29: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>MeasuresAndCaseSplitting</span> <span class='hs-keyword'>where</span>
</pre>
</div>
<h2 id="measures">Measures</h2>
<p>Let’s define a simple data type with three alternatives</p>
<pre><span class=hs-linenum>40: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>A</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>B</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> 
</pre>
<p>and a measure that turns <code>ABD</code> into an integer</p>
<pre><span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>toInt</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-definition'>toInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>48: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {VV : GHC.Types.Int | VV == MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-definition'>toInt</span></a> <span class='hs-conid'>A</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>toInt</span> <span class='hs-conid'>B</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>
<span class=hs-linenum>50: </span><span class='hs-definition'>toInt</span> <span class='hs-conid'>C</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>3</span> 
</pre>
<p>Though obvious to us, Liquid Haskell will fail to check that <code>toInt</code> of any <code>ABC</code> argument gives back a natural number. Or, the following call leads to a refinement type error.</p>
<pre><span class=hs-linenum>59: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>unsafe</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>60: </span><span class='hs-keyword'>unsafe</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>61: </span><span class=hs-error><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-keyword'>unsafe</span></a></span> <a class=annot href="#"><span class=annottext>MeasuresAndCaseSplitting.ABC</span><span class='hs-varid'>x</span></a>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>Why? By turning <code>toInt</code> into a measure, Liquid Haskell gives precise information to each data constructor of <code>ABC</code>. Thus it knows that <code>toInt</code> or <code>A</code>, <code>B</code>, and <code>C</code> is respectively <code>1</code>, <code>2</code>, and <code>3</code>, by <em>automatically</em> generating the following types:</p>
<pre><span class=hs-linenum>72: </span><span class='hs-conid'>A</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>toInt</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>73: </span><span class='hs-conid'>B</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>toInt</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>74: </span><span class='hs-conid'>C</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>toInt</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-num'>3</span> <span class='hs-layout'>}</span>
</pre>
<p>Thus, to get the <code>toInt</code> information one need to explicitly perform case analysis on an <code>ABC</code> argument. The following code is safe</p>
<pre><span class=hs-linenum>82: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>safe</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>83: </span><span class='hs-keyword'>safe</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>84: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-keyword'>safe</span></a> <span class='hs-conid'>A</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>85: </span><span class='hs-keyword'>safe</span> <span class='hs-conid'>B</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>86: </span><span class='hs-keyword'>safe</span> <span class='hs-conid'>C</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>Liquid Haskell type check the above code because in the first case the body is checked under the assumption that the argument, call it <code>x</code>, is an <code>A</code>. Under this assumption, <code>toInt x</code> is indeed non negative. Yet, this is the case for the rest two alternatives, where <code>x</code> is either <code>B</code> or <code>C</code>. So, <code>0 &lt;= toInt x</code> holds for all the alternatives, because case analysis on <code>x</code> automatically reasons about the value of the measure <code>toInt</code>.</p>
<p>Now, what if I match the argument <code>x</code> only with <code>A</code> and provide a default body for the rest?</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeBut</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>105: </span><span class='hs-definition'>safeBut</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>106: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-definition'>safeBut</span></a> <span class='hs-conid'>A</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>107: </span><span class='hs-definition'>safeBut</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>Liquid Haskell knows that if the argument <code>x</code> is actually an <code>A</code>, then <code>toInt x</code> is not negative, but does not know the value of <code>toInt</code> for the default case.</p>
<p>But, <em>by default</em> Liquid Haskell will do the the case expansion of the default case for you and rewrite your code to match <code>_</code> with all the possible cases. Thus, Liquid Haskell will internally rewrite <code>safeBut</code> as</p>
<pre><span class=hs-linenum>119: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeButLH</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>120: </span><span class='hs-definition'>safeButLH</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>121: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-definition'>safeButLH</span></a> <span class='hs-conid'>A</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>122: </span><span class='hs-definition'>safeButLH</span> <span class='hs-conid'>B</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>123: </span><span class='hs-definition'>safeButLH</span> <span class='hs-conid'>C</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>With this rewrite Liquid Haskell gets precision! Thus, it has all the information it needs to prove <code>safeBut</code> as safe. Yet, it repeats the code of the default case, thus verification slows down.</p>
<p>In this example, we only have three case alternatives, so we only repeat the code two times with a minor slow down. In cases with many more alternatives repeating the code of the default case can kill the verification time.</p>
<p>For that reason, Liquid Haskell comes with the <code>no-case-expand</code> flag that deactivates this expansion of the default cases. With the <code>no-case-expand</code> flag on, the <code>safeBut</code> code will not type check and to fix it the user needs to perform the case expansion manually.</p>
<p>In short, the <code>no-case-expand</code> increases verification speed but reduces precision. Then it is up to the user to manually expand the default cases, as required, to restore all the precision required for the code to type check.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2018/02/23/measures-and-case-splitting.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2018/02/23/measures-and-case-splitting.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Splitting and Splicing Intervals (Part 2)</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/24/splitting-and-splicing-intervals-II.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/24/splitting-and-splicing-intervals-II.lhs</id>
    <published>true</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Splitting and Splicing Intervals (Part 2)</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Dec 24, 2017
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/reflection.html">reflection</a>, <a href="/tags/abstract-refinements.html">abstract-refinements</a>
              
            </div>

            <br>
			            <p><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs/">Previously</a>, we saw how the principle of <em>“making illegal states unrepresentable”</em> allowed LH to easily enforce a <em>key invariant</em> in <a href="https://twitter.com/nomeata?lang=en">Joachim</a> Breitner’s library for representing sets of integers as <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">sorted lists of intervals</a>.</p>
<p>However, <a href="https://github.com/antalsz/hs-to-coq">Hs-to-coq</a> let Breitner specify and verify that his code properly implemented a <em>set</em> library. Today, lets see how LH’s new <em>“type-level computation”</em> abilities let us reason about the sets of values corresponding to intervals, while using the SMT solver to greatly simplify the overhead of proof.</p>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=RangeSet.hs">demo</a>)</p>
<!-- more -->
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<p><img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ribbon.png" alt="Ribbons"></p>
</div>
<div class="col-lg-2">

</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>42: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>43: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-con"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>44: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-adt"</span>         <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>45: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--diff"</span>           <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--ple"</span>            <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>48: </span>
<span class=hs-linenum>49: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>RangeSet</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>50: </span>
<span class=hs-linenum>51: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>min</span><span class='hs-layout'>,</span> <span class='hs-varid'>max</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>NewProofCombinators</span>
</pre>
</div>
<h2 id="intervals">Intervals</h2>
<p>Recall that the key idea is to represent sets of integers like</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">{ <span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">4</span>}</a></code></pre></div>
<p>as ordered lists of <em>intervals</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">[ (<span class="dv">1</span>, <span class="dv">5</span>), (<span class="dv">7</span>, <span class="dv">8</span>), (<span class="dv">9</span>, <span class="dv">13</span>) ]</a></code></pre></div>
<p>where each pair <code>(i, j)</code> represents the set <code>{i, i+1,..., j-1}</code>.</p>
<p>To verify that the implementation correctly implements a set data type, we need a way to</p>
<ol type="1">
<li><em>Specify</em> the set of values being described,</li>
<li><em>Establish</em> some key properties of these sets.</li>
</ol>
<h2 id="range-sets-semantics-of-intervals">Range-Sets: Semantics of Intervals</h2>
<p>We can describe the set of values corresponding to (i.e. “the semantics of”) an interval <code>i, j</code> by importing the <code>Data.Set</code> library</p>
<pre><span class=hs-linenum>88: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>S</span>
</pre>
<p>to write a function <code>rng i j</code> that defines the <strong>range-set</strong> <code>i..j</code></p>
<pre><span class=hs-linenum>94: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>rng</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>95: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>rng</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j</span> <span class='hs-comment'>-</span> <span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>96: </span><a class=annot href="#"><span class=annottext>Int -&gt; Int -&gt; (Set Int)</span><span class='hs-definition'>rng</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j</span></a>
<span class=hs-linenum>97: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (Set Int) | v == Set_sng i}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int -&gt; Int -&gt; (Set Int)</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span>
<span class=hs-linenum>98: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
</pre>
<p>The <code>reflect rng</code> <a href="/tags/reflection.html">tells LH</a> that we are going to want to work with the Haskell function <code>rng</code> at the refinement-type level.</p>
<h2 id="equational-reasoning">Equational Reasoning</h2>
<p>To build up a little intuition about the above definition and how LH reasons about Sets, lets write some simple <em>unit proofs</em>. For example, lets check that <code>2</code> is indeed in the range-set <code>rng 1 3</code>, by writing a type signature</p>
<pre><span class=hs-linenum>116: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 1 3) }</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Any <em>implementation</em> of the above type is a <em>proof</em> that <code>2</code> is indeed in <code>rng 1 3</code>. Notice that we can reuse the operators from <code>Data.Set</code> (here, <code>S.member</code>) to talk about set operations in the refinement logic. Lets write this proof in an <a href="http://themattchan.com/docs/algprog.pdf">equational style</a>:</p>
<pre><span class=hs-linenum>126: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 1 3)}</span><span class='hs-definition'>test1</span></a> <span class='hs-conid'>()</span>
<span class=hs-linenum>127: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>1</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span>
<span class=hs-linenum>128: </span>      <span class='hs-comment'>-- by unfolding `rng 1 3`</span>
<span class=hs-linenum>129: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>2</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>130: </span>      <span class='hs-comment'>-- by unfolding `rng 2 3`</span>
<span class=hs-linenum>131: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>132: </span>                          <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>3</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>133: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>134: </span>  <span class='hs-varop'>===</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>135: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>the “proof” uses two library operators:</p>
<ul>
<li><p><code>e1 === e2</code> is an <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/NewProofCombinators.hs#L87-L96">implicit equality</a> that checks <code>e1</code> is indeed equal to <code>e2</code> after <strong>unfolding functions at most once</strong>, and returns a term that equals <code>e1</code> and <code>e2</code>, and</p></li>
<li><p><code>e *** QED</code> <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/NewProofCombinators.hs#L65-L69">converts any term</a> <code>e</code> into a proof.</p></li>
</ul>
<p>The first two steps of <code>test1</code>, simply unfold <code>rng</code> and the final step uses the SMT solver’s decision procedure for sets to check equalities over set operations like <code>S.union</code>, <code>S.singleton</code> and <code>S.member</code>.</p>
<h2 id="reusing-proofs">Reusing Proofs</h2>
<p>Next, lets check that:</p>
<pre><span class=hs-linenum>160: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 0 3) }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>161: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 0 3)}</span><span class='hs-definition'>test2</span></a> <span class='hs-conid'>()</span>
<span class=hs-linenum>162: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>0</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span>
<span class=hs-linenum>163: </span>      <span class='hs-comment'>-- by unfolding and set-theory</span>
<span class=hs-linenum>164: </span>  <span class='hs-varop'>===</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Bool</span><span class='hs-num'>2</span></a> <a class=annot href="#"><span class=annottext>x1:Integer -&gt; x2:Integer -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             || x2} | v == GHC.Classes.||}</span><span class='hs-varop'>||</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>1</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>165: </span>      <span class='hs-comment'>-- by re-using test1 as a lemma</span>
<span class=hs-linenum>166: </span>  <span class='hs-varop'>==?</span> <span class='hs-conid'>True</span> <span class='hs-varop'>?</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; {v : () | Set_mem 2 (RangeSet.rng 1 3)} | v == RangeSet.test1}</span><span class='hs-varid'>test1</span></a> <span class='hs-conid'>()</span>
<span class=hs-linenum>167: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>We could do the proof by unfolding in the equational style. However, <code>test1</code> already establishes that <code>S.member 2 (rng 1 3)</code> and we can reuse this fact using:</p>
<ul>
<li><code>e1 ==? e2 ? pf</code> an <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/NewProofCombinators.hs#L98-L116">explicit equality</a> which checks that <code>e1</code> equals <code>e2</code> <em>because of</em> the extra facts asserted by the <code>Proof</code> named <code>pf</code> (in addition to unfolding functions at most once) and returns a term that equals both <code>e1</code> and <code>e2</code>.</li>
</ul>
<h2 id="proof-by-logical-evaluation">Proof by Logical Evaluation</h2>
<p>Equational proofs like <code>test1</code> and <code>test2</code> often have long chains of calculations that can be tedious to spell out. Fortunately, we taught LH a new trick called <strong>Proof by Logical Evaluation</strong> (PLE) that optionally shifts the burden of performing those calculations onto the machine. For example, PLE completely automates the above proofs:</p>
<pre><span class=hs-linenum>194: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test1_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 1 3) }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>195: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 1 3)}</span><span class='hs-definition'>test1_ple</span></a> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>196: </span>
<span class=hs-linenum>197: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test2_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 0 3) }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>198: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 0 3)}</span><span class='hs-definition'>test2_ple</span></a> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p><strong>Be Warned!</strong> While automation is cool, it can be <em>very</em> helpful to first write out all the steps of an equational proof, at least while building up intuition.</p>
<h2 id="proof-by-induction">Proof by Induction</h2>
<p>At this point, we have enough tools to start proving some interesting facts about range-sets. For example, if <code>x</code> is <em>outside</em> the range <code>i..j</code> then it does not belong in <code>rng i j</code>:</p>
<pre><span class=hs-linenum>216: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_mem</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>{x &lt; i || j &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>217: </span>                 <span class='hs-keyword'>{ not (S.member x (rng i j)) }</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j</span> <span class='hs-comment'>-</span> <span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>218: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>We will prove the above <a href="/tags/induction.html">“by induction”</a>. A confession: I always had trouble understanding what exactly <em>proof by induction</em> really meant. Why was it it ok to “do” induction on one thing but not another?</p>
<p><strong>Induction is Recursion</strong></p>
<p>Fortunately, with LH, induction is just recursion. That is,</p>
<ol type="1">
<li><p>We can <strong>recursively</strong> use the same theorem we are trying to prove, but</p></li>
<li><p>We must make sure that the recursive function/proof <strong>terminates</strong>.</p></li>
</ol>
<p>The proof makes this clear:</p>
<pre><span class=hs-linenum>239: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-definition'>lem_mem</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &lt; i
           || j &lt;= v}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>240: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &gt;= j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j</span>
<span class=hs-linenum>241: </span>      <span class='hs-comment'>-- BASE CASE</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>243: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>244: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>245: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>246: </span>  <span class='hs-varop'>===</span> <span class='hs-conid'>True</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>247: </span>
<span class=hs-linenum>248: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j</span>
<span class=hs-linenum>249: </span>      <span class='hs-comment'>-- INDUCTIVE CASE</span>
<span class=hs-linenum>250: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>251: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>252: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (Set Int) | v == Set_sng i}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>253: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>254: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>255: </span>      <span class='hs-comment'>-- by "induction hypothesis"</span>
<span class=hs-linenum>256: </span>  <span class='hs-varop'>==?</span> <span class='hs-conid'>True</span> <span class='hs-varop'>?</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span> <span class='hs-varid'>x</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>There are two cases.</p>
<ul>
<li><p><strong>Base Case:</strong> As <code>i &gt;= j</code>, we know <code>rng i j</code> is empty, so <code>x</code> cannot be in it.</p></li>
<li><p><strong>Inductive Case</strong> As <code>i &lt; j</code> we can unfold <code>rng i j</code> and then <em>recursively call</em> <code>lem_mem (i+1) j</code> to obtain the fact that <code>x</code> cannot be in <code>i+1..j</code> to complete the proof.</p></li>
</ul>
<p>LH automatically checks that the proof:</p>
<ol type="1">
<li><p><strong>Accounts for all cases</strong>, as otherwise the function is <em>not total</em> i.e. like the <code>head</code> function which is only defined on non-empty lists. (Try deleting a case at the <a href="http://goto.ucsd.edu:8090/index.html#?demo=RangeSet.hs">demo</a> to see what happens.)</p></li>
<li><p><strong>Terminates</strong>, as otherwise the induction is bogus, or in math-speak, not <em>well-founded</em>. We use the <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/README.md#explicit-termination-metrics">explicit termination metric</a> <code>/ [j-i]</code> as a hint to tell LH that in each recursive call, the size of the interval <code>j-i</code> shrinks and is always non-negative. LH checks that is indeed the case, ensuring that we have a legit proof by induction.</p></li>
</ol>
<p><strong>Proof by Evaluation</strong></p>
<p>Once you get the hang of the above style, you get tired of spelling out all the details. Logical evaluation lets us eliminate all the boring calculational steps, leaving the essential bits: the recursive (inductive) skeleton</p>
<pre><span class=hs-linenum>291: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_mem_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>{x &lt; i || j &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>292: </span>                     <span class='hs-keyword'>{not (S.member x (rng i j))}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j</span><span class='hs-comment'>-</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>293: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>294: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-definition'>lem_mem_ple</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &lt; i
           || j &lt;= v}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>295: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &gt;= j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j</span> <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>()</span>
<span class=hs-linenum>296: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j</span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-varid'>lem_mem_ple</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span> <span class='hs-varid'>x</span>
</pre>
<p>The above is just <code>lem_mem</code> sans the (PLE-synthesized) intermediate equalities.</p>
<h2 id="disjointness">Disjointness</h2>
<p>We say that two sets are <em>disjoint</em> if their <code>intersection</code> is <code>empty</code>:</p>
<pre><span class=hs-linenum>309: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>inline</span> <span class='hs-varid'>disjoint</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>310: </span><span class='hs-definition'>disjoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>311: </span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {VV : Bool | VV &lt;=&gt; Set_cap x1 x2 == Set_empty 0}</span><span class='hs-definition'>disjoint</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>b</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cap x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>intersection</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
</pre>
<p>Lets prove that two intervals are disjoint if the first <em>ends</em> before the second <em>begins</em>:</p>
<pre><span class=hs-linenum>318: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_disj</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{j1 &lt;= i2}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>319: </span>                  <span class='hs-keyword'>{disjoint (rng i1 j1) (rng i2 j2)}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j2</span><span class='hs-comment'>-</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>320: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>This proof goes “by induction” on the size of the second interval, i.e. <code>j2-i2</code>:</p>
<pre><span class=hs-linenum>327: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-definition'>lem_disj</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>{i2 : Int | j1 &lt;= i2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>328: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &gt;= j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j2</span>
<span class=hs-linenum>329: </span>      <span class='hs-comment'>-- Base CASE</span>
<span class=hs-linenum>330: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>331: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>332: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
<span class=hs-linenum>333: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>334: </span>  <span class='hs-varop'>===</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>335: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>336: </span>
<span class=hs-linenum>337: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &lt; j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j2</span>
<span class=hs-linenum>338: </span>      <span class='hs-comment'>-- Inductive CASE</span>
<span class=hs-linenum>339: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>340: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>341: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (Set Int) | v == Set_sng i2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>i2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>342: </span>      <span class='hs-comment'>-- by induction and lem_mem</span>
<span class=hs-linenum>343: </span>  <span class='hs-varop'>==?</span> <span class='hs-conid'>True</span> <span class='hs-varop'>?</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-varid'>i2</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-varid'>lem_disj</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>344: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>Here, the operator <code>pf1 &amp;&amp;&amp; pf2</code> conjoins the two facts asserted by <code>pf1</code> and <code>pf2</code>.</p>
<p>Again, we can get PLE to do the boring calculations:</p>
<pre><span class=hs-linenum>353: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_disj_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{j1 &lt;= i2}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>354: </span>                      <span class='hs-keyword'>{disjoint (rng i1 j1) (rng i2 j2)}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j2</span><span class='hs-comment'>-</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>355: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>356: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-definition'>lem_disj_ple</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>{i2 : Int | j1 &lt;= i2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>357: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &gt;= j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>358: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &lt; j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a>  <span class='hs-varid'>j2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-varid'>i2</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-varid'>lem_disj_ple</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j2</span>
</pre>
<h2 id="splitting-intervals">Splitting Intervals</h2>
<p>Finally, we can establish the <strong>splitting property</strong> of an interval <code>i..j</code>, that is, given some <code>x</code> that lies between <code>i</code> and <code>j</code> we can <strong>split</strong> <code>i..j</code> into <code>i..x</code> and <code>x..j</code>. We define a predicate that a set <code>s</code> can be split into <code>a</code> and <code>b</code> as:</p>
<pre><span class=hs-linenum>372: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>inline</span> <span class='hs-varid'>split</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>373: </span><span class='hs-definition'>split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>374: </span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; x3:(Set Int) -&gt; {VV : Bool | VV &lt;=&gt; x1 == Set_cup x2 x3
                                                                    &amp;&amp; Set_cap x2 x3 == Set_empty 0}</span><span class='hs-definition'>split</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>s</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>b</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Bool</span><span class='hs-varid'>s</span></a> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
</pre>
<p>We can now state and prove the <strong>splitting property</strong> as:</p>
<pre><span class=hs-linenum>380: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-keyword'>{x &lt;= j}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>381: </span>                   <span class='hs-keyword'>{split (rng i j) (rng i x) (rng x j)}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-comment'>-</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>382: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>383: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{j : Int | x2 &lt;= j} -&gt; {VV : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                         &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0}</span><span class='hs-definition'>lem_split</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>{v : Int | i &lt;= v}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{j : Int | x &lt;= j}</span><span class='hs-varid'>t</span></a>
<span class=hs-linenum>384: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i == x}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>385: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; x}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a>  <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{j : Int | x2 &lt;= j} -&gt; {VV : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                         &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-varid'>t</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span>
</pre>
<p>(We’re using PLE here quite aggressively, can <em>you</em> work out the equational proof?)</p>
<h2 id="set-operations">Set Operations</h2>
<p>The splitting abstraction is a wonderful hammer that lets us break higher-level proofs into the bite sized pieces suitable for the SMT solver’s decision procedures.</p>
<p><strong>Subset</strong></p>
<p>An interval <code>i1..j1</code> is <em>enclosed by</em> <code>i2..j2</code> if <code>i2 &lt;= i1 &lt; j1 &lt;= j2</code>. Lets verify that the range-set of an interval is <strong>contained</strong> in that of an enclosing one.</p>
<pre><span class=hs-linenum>406: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_sub</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i1 &lt; j1}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>407: </span>               <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i2 &lt; j2 &amp;&amp; i2 &lt;= i1 &amp;&amp; j1 &lt;= j2 }</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>408: </span>                 <span class='hs-keyword'>{ S.isSubsetOf (rng i1 j1) (rng i2 j2) }</span>
<span class=hs-linenum>409: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>Here’s a “proof-by-picture”. We can split the larger interval <code>i2..j2</code> into smaller pieces, <code>i2..i1</code>, <code>i1..j1</code> and <code>j1..j2</code> one of which is the <code>i1..j1</code>, thereby completing the proof:</p>
<br>
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<img src="/static/img/lem_sub.png" title="lem_sub proof by picture" alt="lem_sub a proof by picture" />
</div>
<div class="col-lg-2">

</div>
</div>
<p><br></p>
<p>The intuition represented by the picture can distilled into the following proof, that invokes <code>lem_split</code> to carve <code>i2..j2</code> into the relevant sub-intervals:</p>
<pre><span class=hs-linenum>432: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2
                                                              &amp;&amp; x3 &lt;= x1
                                                              &amp;&amp; x2 &lt;= j2} -&gt; {VV : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}</span><span class='hs-definition'>lem_sub</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>{j1 : Int | i1 &lt; j1}</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>{j2 : Int | i2 &lt; j2
            &amp;&amp; i2 &lt;= i1
            &amp;&amp; j1 &lt;= j2}</span><span class='hs-varid'>j2</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-varid'>j2</span>
</pre>
<p><strong>Union</strong></p>
<p>An interval <code>i1..j1</code> <em>overlaps</em> <code>i2..j2</code> if <code>i1 &lt;= j2 &lt;= i2</code>, that is, if the latter ends somewhere inside the former. The same splitting hammer lets us compute the union of two overlapping intervals simply by picking the interval defined by the <em>endpoints</em>.</p>
<pre><span class=hs-linenum>446: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_union</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>447: </span>      <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i1 &lt; j1}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>448: </span>      <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i2 &lt; j2 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt;= j1 }</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>449: </span>        <span class='hs-keyword'>{ rng (min i1 i2) j1 = S.union (rng i1 j1) (rng i2 j2) }</span>
<span class=hs-linenum>450: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<br>
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<img src="/static/img/lem_union.png" title="lem_union proof by picture" alt="lem_union a proof by picture" />
</div>
<div class="col-lg-2">

</div>
</div>
<p><br></p>
<p>The pictorial proof illustrates the two cases:</p>
<ol type="1">
<li><p><code>i1..j1</code> encloses <code>i2..j2</code>; here the union is just <code>i1..j1</code>,</p></li>
<li><p><code>i1..j1</code> only overlaps <code>i1..j1</code>; here the union is <code>i2..j1</code> which can be split into <code>i2..i1</code>, <code>i1..j2</code> and <code>j2..j1</code> which are exactly the union of the intervals <code>i1..j1</code> and <code>i2..j2</code>.</p></li>
</ol>
<p>Again, we render the picture into a formal proof as:</p>
<pre><span class=hs-linenum>474: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2
                                                              &amp;&amp; x1 &lt;= j2
                                                              &amp;&amp; j2 &lt;= x2} -&gt; {VV : () | RangeSet.rng (RangeSet.min x1 x3) x2 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}</span><span class='hs-definition'>lem_union</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>{j1 : Int | i1 &lt; j1}</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>{j2 : Int | i2 &lt; j2
            &amp;&amp; i1 &lt;= j2
            &amp;&amp; j2 &lt;= j1}</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>475: </span>  <span class='hs-comment'>-- i1..j1 encloses i2..j2</span>
<span class=hs-linenum>476: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i1 &lt; i2}</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>i2</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; x3:Int -&gt; x4:{v : Int | x3 &lt; v
                                                                &amp;&amp; x3 &lt;= x1
                                                                &amp;&amp; x2 &lt;= v} -&gt; {v : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)} | v == RangeSet.lem_sub}</span><span class='hs-varid'>lem_sub</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>477: </span>  <span class='hs-comment'>-- i1..j1 overlaps i2..j2</span>
<span class=hs-linenum>478: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>479: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>480: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span>
</pre>
<p><strong>Intersection</strong></p>
<p>Finally, we check that the intersection of two overlapping intervals is given by their <em>inner-points</em>.</p>
<pre><span class=hs-linenum>489: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_intersect</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>490: </span>      <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i1 &lt; j1}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>491: </span>      <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i2 &lt; j2 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt;= j1 }</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>492: </span>        <span class='hs-keyword'>{rng (max i1 i2) j2 = S.intersection (rng i1 j1) (rng i2 j2)}</span>
<span class=hs-linenum>493: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<br>
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<img src="/static/img/lem_intersect.png" title="lem_intersect proof by picture" alt="lem_intersect a proof by picture" />
</div>
<div class="col-lg-2">

</div>
</div>
<p><br></p>
<p>We have the same two cases as for <code>lem_union</code></p>
<ol type="1">
<li><p><code>i1..j1</code> encloses <code>i2..j2</code>; here the intersection is just <code>i2..j2</code>,</p></li>
<li><code>i1..j1</code> only overlaps <code>i1..j1</code>; here the intersection is the <em>middle segment</em> <code>i1..j2</code>, which we obtain by
<ol type="a">
<li><em>splitting</em> <code>i1..j1</code> at <code>j2</code>,</li>
<li><em>splitting</em> <code>i2..j2</code> at <code>i1</code>,</li>
<li><em>discarding</em> the end segments which do not belong in the intersection.</li>
</ol></li>
</ol>
<pre><span class=hs-linenum>517: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2
                                                              &amp;&amp; x1 &lt;= j2
                                                              &amp;&amp; j2 &lt;= x2} -&gt; {VV : () | RangeSet.rng (RangeSet.max x1 x3) x4 == Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}</span><span class='hs-definition'>lem_intersect</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>{j1 : Int | i1 &lt; j1}</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>{j2 : Int | i2 &lt; j2
            &amp;&amp; i1 &lt;= j2
            &amp;&amp; j2 &lt;= j1}</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>518: </span>  <span class='hs-comment'>-- i1..j1 encloses i2..j2</span>
<span class=hs-linenum>519: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i1 &lt; i2}</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>i2</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; x3:Int -&gt; x4:{v : Int | x3 &lt; v
                                                                &amp;&amp; x3 &lt;= x1
                                                                &amp;&amp; x2 &lt;= v} -&gt; {v : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)} | v == RangeSet.lem_sub}</span><span class='hs-varid'>lem_sub</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>520: </span>  <span class='hs-comment'>-- i1..j1 overlaps i2..j2</span>
<span class=hs-linenum>521: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>522: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span>
<span class=hs-linenum>523: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | x2 &lt;= v} -&gt; x4:Int -&gt; {v : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0} | v == RangeSet.lem_disj}</span><span class='hs-varid'>lem_disj</span></a>  <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>     <span class='hs-comment'>-- discard i2..i1</span>
<span class=hs-linenum>524: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | x2 &lt;= v} -&gt; x4:Int -&gt; {v : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0} | v == RangeSet.lem_disj}</span><span class='hs-varid'>lem_disj</span></a>  <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j1</span>     <span class='hs-comment'>-- discard j2..j1</span>
</pre>
<h2 id="conclusions">Conclusions</h2>
<p>Whew. That turned out a lot longer than I’d expected!</p>
<p>On the bright side, we saw how to:</p>
<ol type="1">
<li><em>Specify</em> the semantics of range-sets,</li>
<li><em>Write</em> equational proofs using plain Haskell code,</li>
<li><em>Avoid</em> boring proof steps using PLE,</li>
<li><em>Verify</em> key properties of operations on range-sets.</li>
</ol>
<p>Next time we’ll finish the series by showing how to use the above lemmas to specify and verify the correctness of <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">Breitner’s implementation</a>.</p>
<div class="hidden">
<pre><span class=hs-linenum>547: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>548: </span><span class='hs-comment'>-- | Some helper definitions</span>
<span class=hs-linenum>549: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>550: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>min</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>551: </span><span class='hs-definition'>min</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>552: </span><a class=annot href="#"><span class=annottext>(Ord a) =&gt;
x2:a -&gt; x3:a -&gt; {VV : a | VV == RangeSet.min x2 x3
                          &amp;&amp; VV == (if x2 &lt; x3 then x2 else x3)}</span><span class='hs-definition'>min</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-keyword'>if</span></a> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>y</span>
<span class=hs-linenum>553: </span>
<span class=hs-linenum>554: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>max</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>555: </span><span class='hs-definition'>max</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>556: </span><a class=annot href="#"><span class=annottext>(Ord a) =&gt;
x2:a -&gt; x3:a -&gt; {VV : a | VV == RangeSet.max x2 x3
                          &amp;&amp; VV == (if x2 &lt; x3 then x3 else x2)}</span><span class='hs-definition'>max</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-keyword'>if</span></a> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>557: </span>
<span class=hs-linenum>558: </span><span class='hs-definition'>rng</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>559: </span><span class='hs-definition'>test1</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>560: </span><span class='hs-definition'>test2</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>561: </span><span class='hs-definition'>test1_ple</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>562: </span><span class='hs-definition'>test2_ple</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>563: </span><span class='hs-definition'>lem_mem</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>564: </span><span class='hs-definition'>lem_mem_ple</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>565: </span><span class='hs-definition'>lem_sub</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>566: </span><span class='hs-definition'>lem_disj</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>567: </span><span class='hs-definition'>lem_disj_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>568: </span><span class='hs-definition'>lem_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>569: </span>
<span class=hs-linenum>570: </span><span class='hs-definition'>lem_intersect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>571: </span><span class='hs-definition'>lem_union</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>572: </span><span class='hs-comment'>-- https://ucsd-progsys.github.io/liquidhaskell-blog/tags/induction.html</span>
<span class=hs-linenum>573: </span>
</pre>
</div>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/24/splitting-and-splicing-intervals-II.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/12/24/splitting-and-splicing-intervals-II.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Splitting and Splicing Intervals (Part 1)</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs</id>
    <published>true</published>
    <updated>2017-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Splitting and Splicing Intervals (Part 1)</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Dec 15, 2017
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/reflection.html">reflection</a>, <a href="/tags/abstract-refinements.html">abstract-refinements</a>
              
            </div>

            <br>
			            <p><a href="https://twitter.com/nomeata?lang=en">Joachim Breitner</a> wrote a <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">cool post</a> describing a library for representing sets of integers as <em>sorted lists of intervals</em>, and how they were able to formally verify the code by translating it to Coq using their <a href="https://github.com/antalsz/hs-to-coq">nifty new tool</a>.</p>
<ul>
<li><p>First, lets just see how plain refinement types let us specify the key “goodness” invariant, and check it automatically.</p></li>
<li><p>Next, we’ll see how LH’s new “type-level computation” abilities let us specify and check “correctness”, and even better, understand <em>why</em> the code works.</p></li>
</ul>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=IntervalSets.hs">demo</a>)</p>
<!-- more -->
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ribbon.png"
       alt="Ribbons" height="150">
</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>41: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>42: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-con"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>43: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-adt"</span>         <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>44: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--prune-unsorted"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>45: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span>
<span class=hs-linenum>48: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>49: </span>
<span class=hs-linenum>50: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Interval</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span>
<span class=hs-linenum>51: </span>  <span class='hs-layout'>{</span> <span class='hs-varid'>from</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>52: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>to</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>53: </span>  <span class='hs-layout'>}</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Show Interval)</span><span class='hs-conid'>Show</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>54: </span>
</pre>
</div>
<h2 id="encoding-sets-as-intervals">Encoding Sets as Intervals</h2>
<p>The key idea underlying the intervals data structure, is that we can represent sets of integers like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">{ <span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">4</span>}</a></code></pre></div>
<p>by first <em>ordering</em> them into a list</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">[ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span> ]</a></code></pre></div>
<p>and then <em>partitioning</em> the list into compact intervals</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">[ (<span class="dv">1</span>, <span class="dv">5</span>), (<span class="dv">7</span>, <span class="dv">8</span>), (<span class="dv">9</span>, <span class="dv">13</span>) ]</a></code></pre></div>
<p>That is,</p>
<ol type="1">
<li><p>Each interval <code>(from, to)</code> corresponds to the set <code>{from,from+1,...,to-1}</code>.</p></li>
<li><p>Ordering ensures there is a canonical representation that simplifies interval operations.</p></li>
</ol>
<h2 id="making-illegal-intervals-unrepresentable">Making Illegal Intervals Unrepresentable</h2>
<p>We require that the list of intervals be “sorted, non-empty, disjoint and non-adjacent”. Lets follow the slogan of <em>make-illegal-values-unrepresentable</em> to see how we can encode the legality constraints with refinements.</p>
<p><strong>A Single Interval</strong></p>
<p>We can ensure that each interval is <strong>non-empty</strong> by refining the data type for a single interval to specify that the <code>to</code> field must be strictly bigger than the <code>from</code> field:</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Interval</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span>
<span class=hs-linenum>105: </span>      <span class='hs-layout'>{</span> <span class='hs-varid'>from</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>106: </span>      <span class='hs-layout'>,</span> <span class='hs-varid'>to</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>from</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>107: </span>      <span class='hs-layout'>}</span>
<span class=hs-linenum>108: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>Now, LH will ensure that we can only construct <em>legal</em>, non-empty <code>Interval</code>s</p>
<pre><span class=hs-linenum>115: </span><a class=annot href="#"><span class=annottext>Interval</span><span class='hs-definition'>goodItv</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>10</span> <span class='hs-num'>20</span>
<span class=hs-linenum>116: </span><a class=annot href="#"><span class=annottext>Interval</span><span class='hs-definition'>badItv</span></a>  <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>20</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>10</span></span>     <span class='hs-comment'>-- ILLEGAL: empty interval!</span>
</pre>
<p><strong>Many Intervals</strong></p>
<p>We can represent arbitrary sets as a <em>list of</em> <code>Interval</code>s:</p>
<pre><span class=hs-linenum>124: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Intervals</span> <span class='hs-layout'>{</span> <span class='hs-varid'>itvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Interval</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>
</pre>
<p>The plain Haskell type doesn’t have enough teeth to enforce legality, specifically, to ensure <em>ordering</em> and the absence of <em>overlaps</em>. Refinements to the rescue!</p>
<p>First, we specify a <em>lower-bounded</em> <code>Interval</code> as:</p>
<pre><span class=hs-linenum>134: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>LbItv</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Interval</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>from</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Intuitively, an <code>LbItv n</code> is one that starts (at or) after <code>n</code>.</p>
<p>Next, we use the above to define an <em>ordered list</em> of lower-bounded intervals:</p>
<pre><span class=hs-linenum>143: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LbItv</span> <span class='hs-conid'>N</span><span class='hs-keyglyph'>]</span><span class='hs-varop'>&lt;</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>vHd</span> <span class='hs-varid'>vTl</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>to</span> <span class='hs-varid'>vHd</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>from</span> <span class='hs-varid'>vTl</span><span class='hs-layout'>}</span><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>The signature above uses an <a href="/tags/abstract-refinements.html">abstract-refinement</a> to capture the legality requirements.</p>
<ol type="1">
<li><p>An <code>OrdInterval N</code> is a list of <code>Interval</code> that are lower-bounded by <code>N</code>, and</p></li>
<li><p>In each sub-list, the head <code>Interval</code> <code>vHd</code> <em>precedes</em> each in the tail <code>vTl</code>.</p></li>
</ol>
<h2 id="legal-intervals">Legal Intervals</h2>
<p>We can now describe legal <code>Intervals</code> simply as:</p>
<pre><span class=hs-linenum>161: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Intervals</span> <span class='hs-layout'>{</span> <span class='hs-varid'>itvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>LH will now ensure that illegal <code>Intervals</code> are not representable.</p>
<pre><span class=hs-linenum>167: </span><a class=annot href="#"><span class=annottext>Intervals</span><span class='hs-definition'>goodItvs</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-keyglyph'>[</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>1</span> <span class='hs-num'>5</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>7</span> <span class='hs-num'>8</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>9</span> <span class='hs-num'>13</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- LEGAL</span>
<span class=hs-linenum>168: </span>
<span class=hs-linenum>169: </span><a class=annot href="#"><span class=annottext>Intervals</span><span class='hs-definition'>badItvs1</span></a>  <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>[</span></span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>7</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>5</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>8</span></span><span class=hs-error><span class='hs-keyglyph'>]</span></span>          <span class='hs-comment'>-- ILLEGAL: overlap!</span>
<span class=hs-linenum>170: </span><a class=annot href="#"><span class=annottext>Intervals</span><span class='hs-definition'>badItvs2</span></a>  <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>[</span></span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>5</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>9</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>13</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>7</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>8</span></span><span class=hs-error><span class='hs-keyglyph'>]</span></span>  <span class='hs-comment'>-- ILLEGAL: disorder!</span>
</pre>
<p>Do the types <em>really</em> capture the legality requirements? In the original code, Breitner described goodness as a recursively defined predicate that takes an additional <em>lower bound</em> <code>lb</code> and returns <code>True</code> iff the representation was legal:</p>
<pre><span class=hs-linenum>180: </span><span class='hs-definition'>goodLIs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Interval</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>181: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; {v : Bool | v}</span><span class='hs-definition'>goodLIs</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>182: </span><span class='hs-definition'>goodLIs</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Bool</span><span class='hs-varid'>lb</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f &lt; t}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>t</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; {v : Bool | v}</span><span class='hs-varid'>goodLIs</span></a> <span class='hs-varid'>t</span> <span class='hs-varid'>is</span>
</pre>
<p>We can check that our type-based representation is indeed legit by checking that <code>goodLIs</code> returns <code>True</code> whenever it is called with a valid of <code>OrdItvs</code>:</p>
<pre><span class=hs-linenum>190: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>goodLIs</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>is</span><span class='hs-conop'>:</span><span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v :</span> <span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v }</span> <span class='hs-keyword'>@-}</span>
</pre>
<h2 id="algorithms-on-intervals">Algorithms on Intervals</h2>
<p>We represent legality as a type, but is that <em>good for</em>? After all, we could, as seen above, just as well have written a predicate <code>goodLIs</code>? The payoff comes when it comes to <em>using</em> the <code>Intervals</code> e.g. to implement various set operations.</p>
<p>For example, here’s the code for <em>intersecting</em> two sets, each represented as intervals. We’ve made exactly one change to the function implemented by Breitner: we added the extra lower-bound parameter <code>lb</code> to the recursive <code>go</code> to make clear that the function takes two <code>OrdItvs lb</code> and returns an <code>OrdItvs lb</code>.</p>
<pre><span class=hs-linenum>210: </span><span class='hs-definition'>intersect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span>
<span class=hs-linenum>211: </span><a class=annot href="#"><span class=annottext>Intervals -&gt; Intervals -&gt; Intervals</span><span class='hs-definition'>intersect</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}</span><span class='hs-varid'>go</span></a> <span class='hs-num'>0</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>212: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>213: </span>    <span class='hs-keyword'>{-@</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>214: </span>    <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class=hs-linenum>215: </span>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class=hs-linenum>216: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>217: </span>      <span class='hs-comment'>-- reorder for symmetry</span>
<span class=hs-linenum>218: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt; t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>t2</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>219: </span>      <span class='hs-comment'>-- disjoint</span>
<span class=hs-linenum>220: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f1 &gt;= t2}</span><span class='hs-varid'>f1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>t2</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>221: </span>      <span class='hs-comment'>-- subset</span>
<span class=hs-linenum>222: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 == t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>t2</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f'</span> <span class='hs-varid'>t2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>223: </span>      <span class='hs-comment'>-- overlapping</span>
<span class=hs-linenum>224: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f2 &lt; f1}</span><span class='hs-varid'>f2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>f1</span>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f'</span> <span class='hs-varid'>t2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>225: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>226: </span>      <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>{v : Int | v == (if f1 &gt; f2 then f1 else f2)}</span><span class='hs-varid'>f'</span></a>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == (if x1 &gt; x2 then x1 else x2)}</span><span class='hs-varid'>max</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span>
</pre>
<h2 id="internal-vs-external-verification">Internal vs External Verification</h2>
<p>By representing legality <strong>internally</strong> as a refinement type, as opposed to <strong>externally</strong> as predicate (<code>goodLIs</code>) we have exposed enough information about the structure of the values that LH can <em>automatically</em> chomp through the above code to guarantee that we haven’t messed up the invariants.</p>
<p>To appreciate the payoff, compare to the effort needed to verify legality using the external representation used in the <a href="https://github.com/antalsz/hs-to-coq/blob/8f84d61093b7be36190142c795d6cd4496ef5aed/examples/intervals/Proofs.v#L370-L439">hs-to-coq proof</a>.</p>
<p>The same principle and simplification benefits apply to both the <code>union</code></p>
<pre><span class=hs-linenum>245: </span><span class='hs-definition'>union</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span>
<span class=hs-linenum>246: </span><a class=annot href="#"><span class=annottext>Intervals -&gt; Intervals -&gt; Intervals</span><span class='hs-definition'>union</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}</span><span class='hs-varid'>go</span></a> <span class='hs-num'>0</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>247: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>248: </span>    <span class='hs-keyword'>{-@</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>249: </span>    <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>[Interval]</span><span class='hs-varid'>is</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span>
<span class=hs-linenum>250: </span>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>is</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span>
<span class=hs-linenum>251: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>252: </span>      <span class='hs-comment'>-- reorder for symmetry</span>
<span class=hs-linenum>253: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt; t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>254: </span>      <span class='hs-comment'>-- disjoint</span>
<span class=hs-linenum>255: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f1 &gt; t2}</span><span class='hs-varid'>f1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt; x2}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>i2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>256: </span>      <span class='hs-comment'>-- overlapping</span>
<span class=hs-linenum>257: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f'</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>258: </span>      <span class='hs-keyword'>where</span>
<span class=hs-linenum>259: </span>        <a class=annot href="#"><span class=annottext>{v : Int | v == (if f1 &lt; f2 then f1 else f2)}</span><span class='hs-varid'>f'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == (if x1 &lt; x2 then x1 else x2)}</span><span class='hs-varid'>min</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span>
</pre>
<p>and the <code>subtract</code> functions too:</p>
<pre><span class=hs-linenum>265: </span><span class='hs-definition'>subtract</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span>
<span class=hs-linenum>266: </span><a class=annot href="#"><span class=annottext>Intervals -&gt; Intervals -&gt; Intervals</span><span class='hs-definition'>subtract</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}</span><span class='hs-varid'>go</span></a> <span class='hs-num'>0</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>267: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>268: </span>    <span class='hs-keyword'>{-@</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>269: </span>    <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>[Interval]</span><span class='hs-varid'>is</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span>
<span class=hs-linenum>270: </span>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class=hs-linenum>271: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>272: </span>      <span class='hs-comment'>-- i2 past i1</span>
<span class=hs-linenum>273: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt;= f2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f2</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t1</span> <span class='hs-varid'>is1</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>274: </span>      <span class='hs-comment'>-- i1 past i2</span>
<span class=hs-linenum>275: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t2 &lt;= f1}</span><span class='hs-varid'>t2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>276: </span>      <span class='hs-comment'>-- i1 contained in i2</span>
<span class=hs-linenum>277: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f2 &lt;= f1}</span><span class='hs-varid'>f2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f1</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt;= t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-varid'>is1</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>278: </span>      <span class='hs-comment'>-- i2 covers beginning of i1</span>
<span class=hs-linenum>279: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f2 &lt;= f1}</span><span class='hs-varid'>f2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f1</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>280: </span>      <span class='hs-comment'>-- -- i2 covers end of i1</span>
<span class=hs-linenum>281: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt;= t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>f2</span> <span class='hs-varid'>is1</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>282: </span>      <span class='hs-comment'>-- i2 in the middle of i1</span>
<span class=hs-linenum>283: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>f2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
</pre>
<p>both of which require <a href="https://github.com/antalsz/hs-to-coq/blob/b7efc7a8dbacca384596fc0caf65e62e87ef2768/examples/intervals/Proofs_Function.v#L319-L382">non-trivial</a> <a href="https://github.com/antalsz/hs-to-coq/blob/8f84d61093b7be36190142c795d6cd4496ef5aed/examples/intervals/Proofs.v#L565-L648">proofs</a> in the <em>external style</em>. (Of course, its possible those proofs can be simplified.)</p>
<h2 id="summing-up-and-looking-ahead">Summing Up (and Looking Ahead)</h2>
<p>I hope the above example illustrates why <em>“making illegal states”</em> unrepresentable is a great principle for engineering code <em>and</em> proofs.</p>
<p>That said, notice that with <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">hs-to-coq</a>, Breitner was able to go <em>far beyond</em> the above legality requirement: he was able to specify and verify the far more important (and difficult) property that the above is a <em>correct</em> implementation of a Set library.</p>
<p>Is it even <em>possible</em>, let alone <em>easier</em> to do that with LH?</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/12/15/splitting-and-splicing-intervals-I.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Arithmetic Overflows</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs</id>
    <published>true</published>
    <updated>2017-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Arithmetic Overflows</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Mar 20, 2017
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/basic.html">basic</a>
              
            </div>

            <br>
			            <p>Computers are great at crunching numbers. However, if programmers aren’t careful, their machines can end up biting off more than they can chew: simple arithmetic operations over very large (or very tiny) inputs can <em>overflow</em> leading to bizarre crashes or vulnerabilities. For example, <a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Joshua Bloch’s classic post</a> argues that nearly all binary searches are broken due to integer overflows. Lets see how we can teach LiquidHaskell to spot such overflows.</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>30: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Bounded</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>31: </span>
<span class=hs-linenum>32: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Exception</span> <span class='hs-layout'>(</span><span class='hs-varid'>assert</span><span class='hs-layout'>)</span>
<span class=hs-linenum>33: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>34: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Prelude</span>
<span class=hs-linenum>35: </span>
<span class=hs-linenum>36: </span><span class='hs-definition'>plusStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>37: </span><span class='hs-definition'>plusLazy</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>38: </span><span class='hs-definition'>mono</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
</pre>
</div>
<h2 id="the-problem">1. The Problem</h2>
<p>LiquidHaskell, like some programmers, likes to make believe that <code>Int</code> represents the set of integers. For example, you might define a function <code>plus</code> as:</p>
<pre><span class=hs-linenum>51: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plus</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v == x + y}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>52: </span><span class='hs-definition'>plus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>53: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-definition'>plus</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
</pre>
<p>The output type of the function states that the returned value is equal to the  result of adding the two inputs.</p>
<p>The above signature lets us “prove” facts like addition by one yields a bigger number:</p>
<pre><span class=hs-linenum>63: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>monoPlus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>64: </span><span class='hs-definition'>monoPlus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>65: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>monoPlus</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2} | v == Bounded.plus}</span><span class='hs-varid'>plus</span></a> <span class='hs-varid'>x</span> <span class='hs-num'>1</span>
</pre>
<p>Unfortunately, the signature for plus and hence, the above “fact” are both lies.</p>
<p>LH <em>checks</em> <code>plus</code> as the same signature is <em>assumed</em> for the primitive <code>Int</code> addition operator <code>Prelude.+</code>. LH has to assume <em>some</em> signature for this “foreign” machine operation, and by default, LH assumes that machine addition behaves like logical addition.</p>
<p>However, this assumption, and its consequences are only true upto a point:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">λ<span class="op">&gt;</span>  monoPlus <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb1-3" title="3">λ<span class="op">&gt;</span>  monoPlus <span class="dv">100</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb1-5" title="5">λ<span class="op">&gt;</span>  monoPlus <span class="dv">10000</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="dt">True</span></a>
<a class="sourceLine" id="cb1-7" title="7">λ<span class="op">&gt;</span>  monoPlus <span class="dv">1000000</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="dt">True</span></a></code></pre></div>
<p>Once we get to <code>maxBound</code> at the very edge of <code>Int</code>, a tiny bump is enough to send us tumbling backwards into a twilight zone.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">λ<span class="op">&gt;</span> monoPlus <span class="fu">maxBound</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">λ<span class="op">&gt;</span> plus <span class="fu">maxBound</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="op">-</span><span class="dv">9223372036854775808</span></a></code></pre></div>
<h2 id="keeping-int-in-their-place">2. Keeping Int In Their Place</h2>
<p>The news isn’t all bad: the glass half full view is that for “reasonable” values like 10, 100, 10000 and 1000000, the machine’s arithmetic <em>is</em> the same as logical arithmetic. Lets see how to impart this wisdom to LH. We do this in two steps: define the <em>biggest</em> <code>Int</code> value, and then, use this value to type the arithmetic operations.</p>
<p><strong>A. The Biggest Int</strong></p>
<p>First, we need a way to talk about “the edge” – i.e. the largest <code>Int</code> value at which overflows occur.</p>
<p>We could use the concrete number</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">λ<span class="op">&gt;</span><span class="ot"> maxBound ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dv">9223372036854775807</span></a></code></pre></div>
<p>However, instead of hardwiring a particular number, a more general strategy is to define a symbolic constant <code>maxInt</code> to represent <em>any</em> arbitrary overflow value and thus, make the type checking robust to different machine integer widths.</p>
<pre><span class=hs-linenum>135: </span><span class='hs-comment'>-- defines an Int constant called `maxInt`</span>
<span class=hs-linenum>136: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>To tell LH that <code>maxInt</code> is the “biggest” <code>Int</code>, we write a predicate that describes values bounded by <code>maxInt</code>:</p>
<pre><span class=hs-linenum>144: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>Bounded</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;</span> <span class='hs-conid'>N</span> <span class='hs-varop'>+</span> <span class='hs-varid'>maxInt</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>maxInt</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Thus, <code>Bounded n</code> means that the number <code>n</code> is in the range <code>[-maxInt, maxInt]</code>.</p>
<p><strong>B. Bounded Machine Arithmetic</strong></p>
<p>Next, we can assign the machine arithmetic operations types that properly capture the possibility of arithmetic overflows. Here are <em>two</em> possible specifications.</p>
<p><strong>Strict: Thou Shalt Not Overflow</strong> A <em>strict</em> specification simply prohibits any overflow:</p>
<pre><span class=hs-linenum>160: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plusStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int|Bounded(x+y)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span><span class='hs-keyword'>|v = x+y}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>161: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 + y) + maxInt
                        &amp;&amp; x1 + y &lt; maxInt} -&gt; {v : Int | v == x1 + x2}</span><span class='hs-definition'>plusStrict</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{y : Int | 0 &lt; (x + y) + maxInt
           &amp;&amp; x + y &lt; maxInt}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | 0 &lt; (x + v) + maxInt
           &amp;&amp; x + v &lt; maxInt
           &amp;&amp; v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
</pre>
<p>The inputs <code>x</code> and <code>y</code> <em>must</em> be such that the result is <code>Bounded</code>, and in that case, the output value is indeed their logical sum.</p>
<p><strong>Lazy: Overflow at Thine Own Risk</strong> Instead, a <em>lazy</em> specification could permit overflows but gives no guarantees about the output when they occur.</p>
<pre><span class=hs-linenum>172: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plusLazy</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span><span class='hs-keyword'>|Bounded(x+y) =&gt; v = x+y}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>173: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | 0 &lt; (x1 + x2) + maxInt
                               &amp;&amp; x1 + x2 &lt; maxInt =&gt; v == x1 + x2}</span><span class='hs-definition'>plusLazy</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
</pre>
<p>The lazy specification says that while <code>plusLazy</code> can be called with any values you like, the result is the logical sum <em>only if there is no overflow</em>.</p>
<p>To understand the difference between the two specifications, lets revisit the <code>monoPlus</code> property using the new machine-arithmetic sensitive signatures:</p>
<pre><span class=hs-linenum>188: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>monoPlusStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>189: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>monoPlusStrict</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | 0 &lt; (x1 + v) + maxInt
                             &amp;&amp; x1 + v &lt; maxInt} -&gt; {v : Int | v == x1 + x2} | v == Bounded.plusStrict}</span><span class='hs-varid'>plusStrict</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>x</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>monoPlusLazy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>monoPlusLazy</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : Int | 0 &lt; (x1 + x2) + maxInt
                                    &amp;&amp; x1 + x2 &lt; maxInt =&gt; v == x1 + x2} | v == Bounded.plusLazy}</span><span class='hs-varid'>plusLazy</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>x</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span>
</pre>
<p>Both are rejected by LH, since, as we saw earlier, the functions <em>do not</em> always evaluate to <code>True</code>. However, in the strict version the error is at the possibly overflowing call to <code>plusStrict</code>. In the lazy version, the call to <code>plusLazy</code> is accepted, but as the returned value is some arbitrary <code>Int</code> (not the logical <code>x+1</code>), the comparison may return <code>False</code> hence the output is not always <code>True</code>.</p>
<p><strong>Exercise:</strong> Can you fix the specification for <code>monoPlusStrict</code> and <code>monoPlusLazy</code> to get LH to verify the implementation?</p>
<h2 id="a-typeclass-for-machine-arithmetic">3. A Typeclass for Machine Arithmetic</h2>
<p>Its a bit inconvenient to write <code>plusStrict</code> and <code>plusLazy</code>, and really, we’d just like to write <code>+</code> and <code>-</code> and so on. We can do so, by tucking the above specifications into a <em>bounded numeric</em> typeclass whose signatures capture machine arithmetic. First, we define a <code>BoundedNum</code> variant of <code>Num</code></p>
<pre><span class=hs-linenum>220: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>BoundedNum</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>221: </span>  <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>222: </span>  <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>223: </span>  <span class='hs-comment'>-- other operations ...</span>
</pre>
<p>and now, we can define its <code>Int</code> instance just as wrappers around the <code>Prelude</code> operations:</p>
<pre><span class=hs-linenum>230: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>BoundedNum</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>231: </span>  <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 + y) + maxInt
                        &amp;&amp; x1 + y &lt; maxInt} -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{y : Int | 0 &lt; (x + y) + maxInt
           &amp;&amp; x + y &lt; maxInt}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | 0 &lt; (x + v) + maxInt
           &amp;&amp; x + v &lt; maxInt
           &amp;&amp; v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
<span class=hs-linenum>232: </span>  <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 - y) + maxInt
                        &amp;&amp; x1 - y &lt; maxInt} -&gt; {v : Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>{y : Int | 0 &lt; (x - y) + maxInt
           &amp;&amp; x - y &lt; maxInt}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | 0 &lt; (x - v) + maxInt
           &amp;&amp; x - v &lt; maxInt
           &amp;&amp; v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 - x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.-</span> <span class='hs-varid'>y</span>
</pre>
<p>Finally, we can tell LH that the above above instance obeys the (strict) specifications for machine arithmetic:</p>
<pre><span class=hs-linenum>239: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>BoundedNum</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>240: </span>      <span class='hs-varop'>+</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int | Bounded (x+y)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v == x+y }</span><span class='hs-layout'>;</span>
<span class=hs-linenum>241: </span>      <span class='hs-comment'>-</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int | Bounded (x-y)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v == x-y }</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>With the above instance in scope, we can just use the plain <code>+</code> operator and have LH flag potential overflows:</p>
<pre><span class=hs-linenum>249: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mono</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>250: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>mono</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-varop'>+</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span>
</pre>
<h2 id="an-application-binary-search">4. An Application: Binary Search</h2>
<p>The above seems a bit paranoid. Do overflows <em>really</em> matter? And if they do, is it really practical to check for them using the above?</p>
<p><a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Joshua Bloch’s</a> famous article describes a tricky overflow bug in an implementation of binary-search that lay hidden in plain sight in classic textbooks and his own implementation in the JDK for nearly a decade. Gabriel Gonzalez wrote a lovely <a href="http://www.haskellforall.com/2015/12/compile-time-memory-safety-using-liquid.html">introduction to LH</a> using binary-search as an example, and a careful reader <a href="https://www.reddit.com/r/haskell/comments/3ysh9k/haskell_for_all_compiletime_memory_safety_using/cyg8g60/">pointed out</a> that it had the same overflow bug!</p>
<p>Lets see how we might spot and fix such bugs using <code>BoundedNum</code>. (<em>Hover over the images to animate</em>.)</p>
<div class="row">
<div class="col-md-4">
<p><strong>A. Off by One</strong> Lets begin by just using the default <code>Num Int</code> which ignores overflow. As Gabriel explains, LH flags a bunch of errors if we start the search with <code>loop x v 0 n</code> as the resulting search can access <code>v</code> at any index between <code>0</code> and <code>n</code> inclusive, which may lead to an out of bounds at <code>n</code>. We can fix the off-by-one by correcting the upper bound to <code>n-1</code>, at which point LH reports the code free of errors.</p>
</div>
<div class="col-md-8">
<p><img id="splash-binarySearch-A"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-A.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-A.png"></p>
</div>
</div>
<p><br></p>
<div class="row">
<div class="col-md-8">
<p><img id="splash-binarySearch-B"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-B.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-B.png"></p>
</div>
<div class="col-md-4">
<p><strong>B. Lots of Overflows</strong> To spot arithmetic overflows, we need only hide the default <code>Prelude</code> and instead import the <code>BoundedNum</code> instance described above. Upon doing so, LH flags a whole bunch of potential errors – essentially <em>all</em> the arithmetic operations which seems rather dire!</p>
</div>
</div>
<div class="row">
<div class="col-md-4">
<p><strong>C. Vector Sizes are Bounded</strong> Of course, things aren’t <em>so</em> bad. LH is missing the information that the size of any <code>Vector</code> must be <code>Bounded</code>. Once we inform LH about this invariant with the <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/README.md#invariants"><code>using</code> directive</a>, it infers that as the <code>lo</code> and <code>hi</code> indices are upper-bounded by the <code>Vector</code>’s size, all the arithmetic on them is also <code>Bounded</code> and hence, free of overflows.</p>
</div>
<div class="col-md-8">
<p><img id="splash-binarySearch-C"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-C.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-C.png"></p>
</div>
</div>
<p><br></p>
<div class="row">
<div class="col-md-8">
<p><img id="splash-binarySearch-D"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-D.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-D.png"></p>
</div>
<div class="col-md-4">
<p><strong>D. Staying In The Middle</strong> Well, <em>almost</em> all. The one pesky pink highlight that remains is exactly the bug that Bloch made famous. Namely: the addition used to compute the new midpoint between <code>lo</code> and <code>hi</code> could overflow e.g. if the array was large and both those indices were near the end. To ensure the machine doesn’t choke, we follow Bloch’s suggestion and re-jigger the computation to instead compute the midpoint by splitting the difference between <code>hi</code> and <code>lo</code>! the code is now free of arithmetic overflows and truly memory safe.</p>
</div>
</div>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/03/20/arithmetic-overflows.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Refinement Reflection on ADTs</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs</id>
    <published>true</published>
    <updated>2016-10-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Refinement Reflection on ADTs</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Oct  6, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/reflection.html">reflection</a>, <a href="/tags/induction.html">induction</a>, <a href="/tags/measures.html">measures</a>
              
            </div>

            <br>
			            <h2 id="lists-are-monoids">Lists are Monoids</h2>
<p><a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">Previously</a> we saw how Refinement Reflection can be used to write Haskell functions that prove theorems about other Haskell functions. Today, we will see how Refinement Reflection works on <strong>recursive data types</strong>. As an example, we will prove that <strong>lists are monoids</strong> (under nil and append).</p>
<p>Lets see how to express <strong>the monoid laws</strong> as liquid types, and then prove the laws by writing plain Haskell functions that are checked by LiquidHaskell.</p>
<!-- more -->
<p><br></p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<p style="text-align:center">
<img class="center-block" src="http://www.aaronartprints.org/images/Paintings/4597.jpg" alt="Recursion" width="300"> <br> Recursive Paper and Pencil Proofs. “Drawing Hands” by Escher. <br>
</p>
</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>     <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--totality"</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>48: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>StructuralInduction</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>49: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
<span class=hs-linenum>50: </span>
<span class=hs-linenum>51: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span>
<span class=hs-linenum>53: </span><span class='hs-definition'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>54: </span><span class='hs-definition'>leftId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>55: </span><span class='hs-definition'>rightId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>56: </span><span class='hs-definition'>associativity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
</pre>
</div>
<h2 id="lists">Lists</h2>
<p>First, lets define the <code>List a</code> data type</p>
<pre><span class=hs-linenum>66: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
</pre>
<h2 id="induction-on-lists">Induction on Lists</h2>
<p>As we will see, <em>proofs</em> by structural induction will correspond to <em>programs</em> that perform recursion on lists. To keep things legit, we must verify that those programs are total and terminating.</p>
<p>To that end, lets define a <code>length</code> function that computes the natural number that is the size of a list.</p>
<pre><span class=hs-linenum>81: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>length</span>               <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>82: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>length</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>83: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                        &amp;&amp; v == length x1}</span><span class='hs-definition'>length</span></a> <span class='hs-conid'>N</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<span class=hs-linenum>84: </span><span class='hs-definition'>length</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1 : int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == length xs
                     &amp;&amp; v == length xs}</span><span class='hs-varid'>length</span></a> <span class='hs-varid'>xs</span>
</pre>
<p>We lift <code>length</code> in the logic, as a <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2014/02/11/the-advantage-of-measures.lhs/">measure</a>.</p>
<p>We can now tell Liquid Haskell that when proving termination on recursive functions with a list argument <code>xs</code>, it should check whether the <code>length xs</code> is decreasing.</p>
<pre><span class=hs-linenum>94: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>length</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> <span class='hs-layout'>{</span><span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<h2 id="reflecting-lists-into-the-logic">Reflecting Lists into the Logic</h2>
<p>To talk about lists in the logic, we use the annotation</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-cons"</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>which <strong>automatically</strong> derives measures for</p>
<ul>
<li><em>testing</em> if a value has a given data constructor, and</li>
<li><em>extracting</em> the corresponding field’s value.</li>
</ul>
<p>For our example, LH will automatically derive the following functions in the refinement logic.</p>
<pre><span class=hs-linenum>116: </span><span class='hs-definition'>isN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- Haskell's null</span>
<span class=hs-linenum>117: </span><span class='hs-definition'>isC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- Haskell's not . null</span>
<span class=hs-linenum>118: </span>
<span class=hs-linenum>119: </span><span class='hs-definition'>select_C_1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>     <span class='hs-comment'>-- Haskell's head</span>
<span class=hs-linenum>120: </span><span class='hs-definition'>select_C_2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span>   <span class='hs-comment'>-- Haskell's tail</span>
</pre>
<p>A programmer <em>never</em> sees the above operators; they are internally used by LH to <strong>reflect</strong> Haskell functions into the refinement logic, as we shall see shortly.</p>
<h2 id="defining-the-monoid-operators">Defining the Monoid Operators</h2>
<p>A structure is a monoid, when it has two operators:</p>
<ul>
<li>the identity element <code>empty</code> and</li>
<li>an associative operator <code>&lt;&gt;</code>.</li>
</ul>
<p>Lets define these two operators for our <code>List</code>.</p>
<ul>
<li>the identity element is the empty list, and</li>
<li>the associative operator <code>&lt;&gt;</code> is list append.</li>
</ul>
<pre><span class=hs-linenum>141: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>empty</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>142: </span><span class='hs-definition'>empty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>143: </span><a class=annot href="#"><span class=annottext>{VV : (StructuralInduction.List a) | VV == empty
                                     &amp;&amp; VV == StructuralInduction.N}</span><span class='hs-definition'>empty</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span>
<span class=hs-linenum>144: </span>
<span class=hs-linenum>145: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infix</span>   <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>146: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>147: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>148: </span><span class='hs-conid'>N</span>        <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; {VV : (StructuralInduction.List a) | VV == &lt;&gt; x1 x2
                                                                                                           &amp;&amp; VV == (if is_N x1 then x2 else StructuralInduction.C (select_C_1 x1) (&lt;&gt; (select_C_2 x1) x2))}</span><span class='hs-varop'>&lt;&gt;</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>ys</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<span class=hs-linenum>149: </span><span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : (StructuralInduction.List a) | VV == &lt;&gt; xs ys
                                     &amp;&amp; VV == (if is_N xs then ys else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) ys))
                                     &amp;&amp; VV == &lt;&gt; xs ys}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
</pre>
<p>LiquidHaskell automatically checked that the recursive <code>(&lt;&gt;)</code> is terminating, by checking that the <code>length</code> of its first argument is decreasing. Since both the above operators are provably terminating, LH lets us reflect them into logic.</p>
<p>As with our <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">previous</a> <code>fibonacci</code> example, reflection of a function into logic, means strengthening the result type of the function with its implementation.</p>
<p>Thus, the <strong>automatically</strong> derived, strengthened types for <code>empty</code> and <code>(&lt;&gt;)</code> will be</p>
<pre><span class=hs-linenum>166: </span><span class='hs-definition'>empty</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-conid'>N</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>167: </span>
<span class=hs-linenum>168: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>169: </span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span> <span class='hs-varop'>&amp;&amp;</span>
<span class=hs-linenum>170: </span>                    <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isN</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>171: </span>                         <span class='hs-conid'>C</span> <span class='hs-layout'>(</span><span class='hs-varid'>select_C_1</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>select_C_2</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<span class=hs-linenum>172: </span>        <span class='hs-layout'>}</span>
</pre>
<p>In effect, the derived checker and selector functions are used to translate Haskell to logic. The above is just to <em>explain</em> how LH reasons about the operators; the programmer never (directly) reads or writes the operators <code>isN</code> or <code>select_C_1</code> etc.</p>
<h2 id="proving-the-monoid-laws">Proving the Monoid Laws</h2>
<p>Finally, we have set everything up, (actually LiquidHaskell did most of the work for us) and we are ready to prove the monoid laws for the <code>List</code>.</p>
<p>First we prove left identity of <code>empty</code>.</p>
<pre><span class=hs-linenum>190: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftId</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ empty &lt;&gt; x == x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>191: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; empty x1 == x1}</span><span class='hs-definition'>leftId</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>192: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>empty</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>193: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>194: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>195: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>This proof was trivial, because left identity is satisfied by the way we defined <code>(&lt;&gt;)</code>.</p>
<p>Next, we prove right identity of <code>empty</code>.</p>
<pre><span class=hs-linenum>204: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>rightId</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ x &lt;&gt; empty  == x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>205: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 empty == x1}</span><span class='hs-definition'>rightId</span></a> <span class='hs-conid'>N</span>
<span class=hs-linenum>206: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List (GHC.Prim.Any *))</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum>207: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *))</span><span class='hs-varop'>==.</span></a> <span class='hs-conid'>N</span>
<span class=hs-linenum>208: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>209: </span>
<span class=hs-linenum>210: </span><span class='hs-definition'>rightId</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>211: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum>212: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>213: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>        <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{VV : () | &lt;&gt; xs empty == xs}</span><span class='hs-varid'>rightId</span></a> <span class='hs-varid'>xs</span>
<span class=hs-linenum>214: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>This proof is more tricky, as it requires <strong>structural induction</strong> which is encoded in LH proofs simply as <strong>recursion</strong>. LH ensures that the inductive hypothesis is appropriately applied by checking that the recursive proof is total and terminating. In the <code>rightId</code> case, for termination, Liquid Haskell checked that <code>length xs &lt; length (C x xs)</code>.</p>
<p>It turns out that we can prove lots of properties about lists using structural induction, encoded in Haskell as</p>
<ul>
<li>case splitting,</li>
<li>recursive calls, and</li>
<li>rewriting,</li>
</ul>
<p>To see a last example, lets prove the associativity of <code>(&lt;&gt;)</code>.</p>
<pre><span class=hs-linenum>233: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>associativity</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>z</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>234: </span>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ x &lt;&gt; (y &lt;&gt; z) == (x &lt;&gt; y) &lt;&gt; z }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>235: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class='hs-definition'>associativity</span></a> <span class='hs-conid'>N</span> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>z</span></a>
<span class=hs-linenum>236: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span>
<span class=hs-linenum>237: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>238: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>239: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>240: </span>
<span class=hs-linenum>241: </span><span class='hs-definition'>associativity</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span>
<span class=hs-linenum>243: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>244: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class='hs-varid'>associativity</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>245: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>246: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>247: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>The above proof of associativity reifies the paper and pencil proof by structural induction.</p>
<p>With that, we can safely conclude that our user defined list is a monoid!</p>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how Refinement Reflection can be used to</p>
<ul>
<li>specify properties of <code>ADTs</code>,</li>
<li>naturally encode structural inductive proofs of these properties, and</li>
<li>have these proofs machine checked by Liquid Haskell.</li>
</ul>
<p>Why is this useful? Because the theorems we prove refer to your Haskell functions! Thus you (or in the future, the compiler) can use properties like monoid or monad laws to optimize your Haskell code. In the future, we will present examples of code optimizations using monoid laws. Stay tuned!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/10/06/structural-induction.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell as a Theorem Prover</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs</id>
    <published>true</published>
    <updated>2016-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Haskell as a Theorem Prover</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Sep 18, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/reflection.html">reflection</a>
              
            </div>

            <br>
			            <p>We’ve taught LiquidHaskell a new trick that we call ``Refinement Reflection’’ which lets us turn Haskell into a theorem prover capable of proving arbitrary properties of code. The key idea is to <strong>reflect</strong> the code of the function into its <strong>output type</strong>, which lets us then reason about the function at the (refinement) type level. Lets see how to use refinement types to express a theorem, for example that fibonacci is a monotonically increasing function, then write plain Haskell code to reify a paper-and-pencil-style proof for that theorem, that can be machine checked by LiquidHaskell.</p>
<!-- more -->
<p><br> <br> <br></p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://eyesofodysseus.files.wordpress.com/2013/06/full-moon-over-ocean-reflection.jpg"
       alt="Reflection" width="300">
</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>38: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>     <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>39: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--totality"</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>RefinementReflection</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>41: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
<span class=hs-linenum>42: </span>
<span class=hs-linenum>43: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>44: </span><span class='hs-definition'>propPlusComm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>45: </span><span class='hs-definition'>propOnePlueOne</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>46: </span><span class='hs-definition'>fibTwo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>47: </span><span class='hs-definition'>fibCongruence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>48: </span><span class='hs-definition'>fibUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>fibTwoPretty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>50: </span><span class='hs-definition'>fibThree</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>51: </span><span class='hs-definition'>fMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span><span class='hs-layout'>)</span>
<span class=hs-linenum>53: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>54: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>55: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>56: </span><span class='hs-definition'>fibMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>57: </span>
</pre>
</div>
<h2 id="shallow-vs.-deep-specifications">Shallow vs. Deep Specifications</h2>
<p>Up to now, we have been using Liquid Haskell to specify and verify “shallow” specifications that abstractly describe the behavior of functions. For example, below, we specify and verify that <code>fib</code>restricted to natural numbers, always terminates returning a natural number.</p>
<pre><span class=hs-linenum>70: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>71: </span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-definition'>fib</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> 
<span class=hs-linenum>72: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>1</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> 
<span class=hs-linenum>73: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
</pre>
<p>In this post we present how refinement reflection is used to verify “deep” specifications that use the exact definition of Haskell functions. For example, we will prove that the Haskell <code>fib</code> function is increasing.</p>
<h2 id="propositions">Propositions</h2>
<p>To begin with, we import <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/ProofCombinators.hs">ProofCombinators</a>, a (Liquid) Haskell library that defines and manipulates logical proofs.</p>
<pre><span class=hs-linenum>89: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
</pre>
<p>A <code>Proof</code> is a data type that carries no run time information</p>
<pre><span class=hs-linenum>95: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>but can be refined with desired logical propositions. For example, the following type states that <code>1 + 1 == 2</code></p>
<pre><span class=hs-linenum>102: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OnePlusOne</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Since the <code>v</code> and <code>Proof</code> are irrelevant, we may as well abbreviate the above to</p>
<pre><span class=hs-linenum>109: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OnePlusOne'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>As another example, the following function type declares that <em>for each</em> <code>x</code> and <code>y</code> the plus operator commutes.</p>
<pre><span class=hs-linenum>117: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PlusComm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>x</span> <span class='hs-varop'>+</span> <span class='hs-varid'>y</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span> <span class='hs-varop'>+</span> <span class='hs-varid'>x</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span> 
</pre>
<h2 id="trivial-proofs">Trivial Proofs</h2>
<p>We prove the above theorems using Haskell programs. The <code>ProofCombinators</code> module defines the <code>trivial</code> proof</p>
<pre><span class=hs-linenum>129: </span><span class='hs-definition'>trivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>130: </span><span class='hs-definition'>trivial</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>and the “casting” operator <code>(***)</code> that makes proof terms look nice:</p>
<pre><span class=hs-linenum>137: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>QED</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>138: </span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>***</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>QED</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>140: </span><span class='hs-keyword'>_</span> <span class='hs-varop'>***</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>Using the underlying SMT’s knowledge on linear arithmetic, we can trivially prove the above propositions.</p>
<pre><span class=hs-linenum>147: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>propOnePlueOne</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OnePlusOne</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>148: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | 1 + 1 == 2}</span><span class='hs-definition'>propOnePlueOne</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
<span class=hs-linenum>149: </span>
<span class=hs-linenum>150: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>propPlusComm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PlusComm</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>151: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : () | x1 + x2 == x2 + x1}</span><span class='hs-definition'>propPlusComm</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
</pre>
<p>We saw how we use SMT’s knowledge on linear arithmetic to trivially prove arithmetic properties. But how can we prove ``deep’’ properties on Haskell’s functions?</p>
<h2 id="refinement-reflection">Refinement Reflection</h2>
<p>Refinement Reflection allows deep specification and verification by reflecting the code implementing a Haskell function into the function’s output refinement type.</p>
<p>Refinement Reflection proceeds in 3 steps: definition, reflection, and application. Consider reflecting the definition of <code>fib</code> into the logic</p>
<pre><span class=hs-linenum>171: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>fib</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>then the following three reflection steps will occur.</p>
<h2 id="step-1-definition">Step 1: Definition</h2>
<p>Reflection of the Haskell function <code>fib</code> defines in logic an <em>uninterpreted</em> function <code>fib</code> that satisfies the congruence axiom.</p>
<p>In the logic the function <code>fib</code> is defined.</p>
<pre><span class=hs-linenum>185: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
</pre>
<p>SMT only knows that <code>fib</code> satisfies the congruence axiom.</p>
<pre><span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibCongruence</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i == j =&gt; fib i == fib j}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 == x2 =&gt; fib x1 == fib x2}</span><span class='hs-definition'>fibCongruence</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
</pre>
<p>Other than congruence, SMT knowns nothing for the function <code>fib</code>, until reflection happens!</p>
<h2 id="step-2-reflection">Step 2: Reflection</h2>
<p>As a second step, Liquid Haskell connects the Haskell function <code>fib</code> with the homonymous logical function, by reflecting the implementation of <code>fib</code> in its result type.</p>
<p>The result type of <code>fib</code> is automatically strengthened to the following.</p>
<pre><span class=hs-linenum>210: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fib</span> <span class='hs-varid'>i</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fibP</span> <span class='hs-varid'>i</span> <span class='hs-layout'>}</span>
</pre>
<p>That is, the result satisfies the <code>fibP</code> predicate exactly reflecting the implementation of <code>fib</code>.</p>
<pre><span class=hs-linenum>217: </span><span class='hs-definition'>fibP</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>i</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyword'>then</span> <span class='hs-num'>0</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>218: </span>         <span class='hs-keyword'>if</span> <span class='hs-varid'>i</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-keyword'>then</span> <span class='hs-num'>1</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>219: </span>         <span class='hs-varid'>fin</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-varid'>fib</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-comment'>-</span><span class='hs-num'>2</span><span class='hs-layout'>)</span>
</pre>
<h2 id="step-3-application">Step 3: Application</h2>
<p>With the reflected refinement type, each application of <code>fib</code> automatically unfolds the definition of <code>fib</code> once. As an example, applying <code>fib</code> to <code>0</code>, <code>1</code>, and <code>2</code> allows us to prove that <code>fib 2 == 1</code>:</p>
<pre><span class=hs-linenum>231: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibTwo</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ fib 2 == 1 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>232: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | fib 2 == 1}</span><span class='hs-definition'>fibTwo</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | null v &lt;=&gt; false}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>Though valid, the above <code>fibTwo</code> proof is not pretty!</p>
<h2 id="structuring-proofs">Structuring Proofs</h2>
<p>To make our proofs look nice, we use combinators from the <code>ProofCombinators</code> library, which exports a family of operators <code>(*.)</code> where <code>*</code> comes from the theory of linear arithmetic and the refinement type of <code>x *. y</code></p>
<ul>
<li><strong>requires</strong> that <code>x *. y</code> holds and</li>
<li><strong>ensures</strong> that the returned value is equal to <code>x</code>.</li>
</ul>
<p>For example, <code>(==.)</code> and <code>(&lt;=.)</code> are predefined in <code>ProofCombinators</code> as</p>
<pre><span class=hs-linenum>252: </span><span class='hs-layout'>(</span><span class='hs-varop'>==.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-layout'>{</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span><span class='hs-varop'>==</span><span class='hs-varid'>y</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>}</span>
<span class=hs-linenum>253: </span><span class='hs-definition'>x</span> <span class='hs-varop'>==.</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>254: </span>
<span class=hs-linenum>255: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;=.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-layout'>{</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span><span class='hs-varop'>&lt;=</span><span class='hs-varid'>y</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>}</span>
<span class=hs-linenum>256: </span><span class='hs-definition'>x</span> <span class='hs-varop'>&lt;=.</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
</pre>
<p>Using these predefined operators, we construct paper and pencil-like proofs for the <code>fib</code> function.</p>
<pre><span class=hs-linenum>263: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibTwoPretty</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{ fib 2 == 1 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>264: </span><a class=annot href="#"><span class=annottext>{VV : () | fib 2 == 1}</span><span class='hs-definition'>fibTwoPretty</span></a> 
<span class=hs-linenum>265: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span> 
<span class=hs-linenum>266: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> 
<span class=hs-linenum>267: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<h2 id="because-operator">Because operator</h2>
<p>To allow the reuse of existing proofs, <code>ProofCombinators</code> defines the because operator <code>(∵)</code></p>
<pre><span class=hs-linenum>279: </span><span class='hs-layout'>(</span><span class='hs-varid'>∵</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>280: </span><span class='hs-definition'>f</span> <span class='hs-varid'>∵</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span>
</pre>
<p>For example, <code>fib 3 == 2</code> holds because <code>fib 2 == 1</code>:</p>
<pre><span class=hs-linenum>286: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibThree</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ fib 3 == 2 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>287: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | fib 3 == 2}</span><span class='hs-definition'>fibThree</span></a> <span class='hs-keyword'>_</span> 
<span class=hs-linenum>288: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>3</span> 
<span class=hs-linenum>289: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>290: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span>      <span class='hs-varid'>∵</span> <span class='hs-varid'>fibTwoPretty</span>
<span class=hs-linenum>291: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <span class='hs-num'>2</span> 
<span class=hs-linenum>292: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<h2 id="proofs-by-induction-i.e.-recursion">Proofs by Induction (i.e. Recursion)</h2>
<p>Next, combining the above operators we specify and prove that <code>fib</code> is increasing, that is for each natural number <code>i</code>, <code>fib i &lt;= fib (i+1)</code>.</p>
<p>We specify the theorem as a refinement type for <code>fubUp</code> and use Haskell code to persuade Liquid Haskell that the theorem holds.</p>
<pre><span class=hs-linenum>309: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fib i &lt;= fib (i+1)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>310: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-definition'>fibUp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a>
<span class=hs-linenum>311: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>
<span class=hs-linenum>312: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>313: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>314: </span>
<span class=hs-linenum>315: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>316: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span>
<span class=hs-linenum>317: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>318: </span>
<span class=hs-linenum>319: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<span class=hs-linenum>320: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>
<span class=hs-linenum>321: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>322: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-varid'>fibUp</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>323: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-varid'>fibUp</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>324: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>325: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>The proof proceeds <em>by induction on</em> <code>i</code>.</p>
<ul>
<li><p>The base cases <code>i == 0</code> and <code>i == 1</code> are represented as Haskell’s case splitting.</p></li>
<li><p>The inductive hypothesis is represented by recursive calls on smaller inputs.</p></li>
</ul>
<p>Finally, the SMT solves arithmetic reasoning to conclude the proof.</p>
<h2 id="higher-order-theorems">Higher Order Theorems</h2>
<p>Refinement Reflection can be used to express and verify higher order theorems! For example, <code>fMono</code> specifies that each locally increasing function is monotonic!</p>
<pre><span class=hs-linenum>345: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>346: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fUp</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>z</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{f z &lt;= f (z+1)}</span><span class='hs-layout'>)</span>
<span class=hs-linenum>347: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span>
<span class=hs-linenum>348: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat|x &lt; y}</span>
<span class=hs-linenum>349: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{f x &lt;= f y}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> 
<span class=hs-linenum>350: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>351: </span><a class=annot href="#"><span class=annottext>x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class='hs-definition'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | f x1 &lt;= f (x1 + 1)}</span><span class='hs-varid'>thm</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; x &lt; v}</span><span class='hs-varid'>y</span></a>  
<span class=hs-linenum>352: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>y</span>
<span class=hs-linenum>353: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>y</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>354: </span>         <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&gt;.</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span>       <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>355: </span>        <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>356: </span>
<span class=hs-linenum>357: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span>
<span class=hs-linenum>358: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>359: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a>  <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>         <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class='hs-varid'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>360: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a>  <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>y</span>             <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>361: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>Again, the recursive implementation of <code>fMono</code> depicts the paper and pencil proof of <code>fMono</code> by induction on the decreasing argument <code>/ [y]</code>.</p>
<p>Since <code>fib</code> is proven to be locally increasing by <code>fUp</code>, we use <code>fMono</code> to prove that <code>fib</code> is monotonic.</p>
<pre><span class=hs-linenum>371: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | n &lt; m }</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fib n &lt;= fib m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>372: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                                           &amp;&amp; x1 &lt; v} -&gt; {VV : () | fib x1 &lt;= fib x2}</span><span class='hs-definition'>fibMono</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                              &amp;&amp; x5 &lt; v} -&gt; {v : () | x1 x5 &lt;= x1 x6} | v == RefinementReflection.fMono}</span><span class='hs-varid'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | fib x1 &lt;= fib (x1 + 1)} | v == RefinementReflection.fibUp}</span><span class='hs-varid'>fibUp</span></a>
</pre>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how refinement reflection turns Haskell into a theorem prover by reflecting the code implementing a Haskell function into the function’s output refinement type.</p>
<p>Refinement Types are used to express theorems, Haskell code is used to prove such theorems expressing paper pencil proofs, and Liquid Haskell verifies the validity of the proofs!</p>
<p>Proving <code>fib</code> monotonic is great, but this is Haskell! Wouldn’t it be nice to prove theorems about inductive data types and higher order functions? Like fusions and folds? Or program equivalence on run-time optimizations like map-reduce?</p>
<p>Stay tuned!</p>
<p>Even better, if you happen you be in Nara for ICFP’16, come to my <a href="http://cufp.org/2016/t6-niki-vazou-liquid-haskell-intro.html">CUFP tutorial</a> for more!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/09/18/refinement-reflection.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Normal Forms</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/01/normal-forms.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/01/normal-forms.lhs</id>
    <published>true</published>
    <updated>2016-09-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Normal Forms</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Sep  5, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/measures.html">measures</a>
              
            </div>

            <br>
			            <p>I have been preparing an undergraduate course on Compilers in which we build a compiler that crunches an ML-like language to X86 assembly. One of my favorite steps in the compilation is the <a href="https://users.soe.ucsc.edu/~cormac/papers/pldi93.pdf">conversion to A-Normal Form (ANF)</a> where, informally speaking, each call or primitive operation’s arguments are <strong>immediate</strong> values, i.e. constants or variable lookups whose values can be loaded with a single machine instruction. For example, the expression</p>
<pre><span class=hs-linenum>25: </span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-num'>12</span> <span class='hs-comment'>-</span> <span class='hs-num'>4</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-num'>7</span> <span class='hs-varop'>+</span> <span class='hs-num'>8</span><span class='hs-layout'>)</span>
</pre>
<p>has the A-Normal Form:</p>
<pre><span class=hs-linenum>31: </span><span class='hs-keyword'>let</span> <span class='hs-varid'>anf0</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-num'>3</span>
<span class=hs-linenum>32: </span>    <span class='hs-varid'>anf1</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>12</span> <span class='hs-comment'>-</span> <span class='hs-num'>4</span>
<span class=hs-linenum>33: </span>    <span class='hs-varid'>anf2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anf0</span> <span class='hs-varop'>*</span> <span class='hs-varid'>anf1</span>
<span class=hs-linenum>34: </span>    <span class='hs-varid'>anf3</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>7</span> <span class='hs-varop'>+</span> <span class='hs-num'>8</span>
<span class=hs-linenum>35: </span><span class='hs-keyword'>in</span>
<span class=hs-linenum>36: </span>    <span class='hs-varid'>anf2</span> <span class='hs-varop'>*</span> <span class='hs-varid'>anf3</span>
</pre>
<p>The usual presentation of ANF conversion is very elegant but relies upon a clever use of <a href="http://matt.might.net/articles/a-normalization/">continuations</a>. Lets look at another perhaps simpler approach, where we can use refinements to light the way.</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>49: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>50: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--total"</span>          <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>51: </span>
<span class=hs-linenum>52: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>ANF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Op</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>isImm</span><span class='hs-layout'>,</span> <span class='hs-varid'>isAnf</span><span class='hs-layout'>,</span> <span class='hs-varid'>toAnf</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>53: </span>
<span class=hs-linenum>54: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>State</span><span class='hs-varop'>.</span><span class='hs-conid'>Lazy</span>
<span class=hs-linenum>55: </span>
<span class=hs-linenum>56: </span><span class='hs-definition'>mkLet</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span>
<span class=hs-linenum>57: </span><span class='hs-definition'>imm</span><span class='hs-layout'>,</span> <span class='hs-varid'>immExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ImmExpr</span><span class='hs-layout'>)</span>
<span class=hs-linenum>58: </span><span class='hs-definition'>anf</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-conid'>AnfExpr</span>
<span class=hs-linenum>59: </span>
<span class=hs-linenum>60: </span><span class='hs-comment'>-- data IExpr</span>
<span class=hs-linenum>61: </span>  <span class='hs-comment'>-- = IInt Int</span>
<span class=hs-linenum>62: </span>  <span class='hs-comment'>-- | IVar Var</span>
<span class=hs-linenum>63: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>64: </span><span class='hs-comment'>-- data AExpr</span>
<span class=hs-linenum>65: </span>  <span class='hs-comment'>-- = AImm IExpr</span>
<span class=hs-linenum>66: </span>  <span class='hs-comment'>-- | ABin Op    IExpr IExpr</span>
<span class=hs-linenum>67: </span>  <span class='hs-comment'>-- | ALet Var   AExpr AExpr</span>
<span class=hs-linenum>68: </span>  <span class='hs-comment'>-- | ALam Var   AExpr</span>
<span class=hs-linenum>69: </span>  <span class='hs-comment'>-- | AApp IExpr IExpr</span>
<span class=hs-linenum>70: </span>
<span class=hs-linenum>71: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span>
<span class=hs-linenum>72: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>ImmExpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span>
</pre>
</div>
<h2 id="source-language">Source Language</h2>
<p>Lets commence by defining the source language that we wish to work with:</p>
<pre><span class=hs-linenum>82: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span>
<span class=hs-linenum>83: </span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EInt</span>  <span class='hs-conid'>Int</span>               <span class='hs-comment'>-- ^ Integers</span>
<span class=hs-linenum>84: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EVar</span>  <span class='hs-conid'>Var</span>               <span class='hs-comment'>-- ^ Variables</span>
<span class=hs-linenum>85: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EBin</span>  <span class='hs-conid'>Op</span>   <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>    <span class='hs-comment'>-- ^ Binary Operators</span>
<span class=hs-linenum>86: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ELet</span>  <span class='hs-conid'>Var</span>  <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>    <span class='hs-comment'>-- ^ Let-binders</span>
<span class=hs-linenum>87: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ELam</span>  <span class='hs-conid'>Var</span>  <span class='hs-conid'>Expr</span>         <span class='hs-comment'>-- ^ Function definitions</span>
<span class=hs-linenum>88: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EApp</span>  <span class='hs-conid'>Expr</span> <span class='hs-conid'>Expr</span>         <span class='hs-comment'>-- ^ Function applications</span>
<span class=hs-linenum>89: </span>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(GHC.Show.Show ANF.Expr)</span><span class='hs-conid'>Show</span></a><span class='hs-layout'>)</span>
</pre>
<p>The language, defined by <code>Expr</code> has integers, variables, binary operators, let-binders and function definitions (lambdas) and calls (applications). In the above, <code>Var</code> and <code>Op</code> are simply:</p>
<pre><span class=hs-linenum>97: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>String</span>
<span class=hs-linenum>98: </span>
<span class=hs-linenum>99: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Op</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Plus</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Minus</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Times</span>
<span class=hs-linenum>100: </span>         <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(GHC.Show.Show ANF.Op)</span><span class='hs-conid'>Show</span></a><span class='hs-layout'>)</span>
</pre>
<p>For example, the source expression above corresponds to the value:</p>
<pre><span class=hs-linenum>106: </span><span class='hs-comment'>-- ((2 + 3) * (12 - 4)) * (7 + 8)</span>
<span class=hs-linenum>107: </span><span class='hs-definition'>srcExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span>
<span class=hs-linenum>108: </span><a class=annot href="#"><span class=annottext>{VV : ANF.Expr | VV /= ANF.e1
                 &amp;&amp; VV /= ANF.e2
                 &amp;&amp; VV /= ANF.e2'
                 &amp;&amp; VV /= ANF.e3
                 &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                      bool])) ((isImm : func(0, [ANF.Expr;
                                                                 GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)}</span><span class='hs-definition'>srcExpr</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-conid'>Times</span>
<span class=hs-linenum>109: </span>            <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-conid'>Times</span>
<span class=hs-linenum>110: </span>              <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-conid'>Plus</span>  <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a>  <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>111: </span>              <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-conid'>Minus</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-num'>12</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-num'>4</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>112: </span>            <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-conid'>Plus</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-num'>7</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-num'>8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<h2 id="a-normal-form">A-Normal Form</h2>
<p>Before we can describe a <em>conversion</em> to A-Normal Form (ANF), we must pin down what ANF <em>is</em>. Our informal description was: ``each call or primitive operation’s arguments are immediate values, i.e. constants or variable lookups’’.</p>
<p>We <em>could</em> define a brand new datatypes, say <code>IExpr</code> and <code>AExpr</code> whose values correspond to <em>immediate</em> and <em>ANF</em> terms. (Try it, as an exercise.) Unfortunately, doing so leads to a bunch of code duplication, e.g. duplicate printers for <code>Expr</code> and <code>AExpr</code>. Instead, lets see how we can use refinements to carve out suitable subsets.</p>
<p><strong>Immediate Expressions</strong></p>
<p>An <code>Expr</code> is <strong>immediate</strong> if it is a <code>Number</code> or a <code>Var</code>; we can formalize this as a Haskell predicate:</p>
<pre><span class=hs-linenum>136: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>isImm</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>137: </span><span class='hs-definition'>isImm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>138: </span><a class=annot href="#"><span class=annottext>x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isImm x1)}</span><span class='hs-definition'>isImm</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>139: </span><span class='hs-definition'>isImm</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>140: </span><span class='hs-definition'>isImm</span> <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
</pre>
<p>and then we can use the predicate to define a refinement type for <em>immediate</em> expressions:</p>
<pre><span class=hs-linenum>147: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>ImmExpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isImm</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>For example, <code>e1</code> is immediate but <code>e2</code> is not:</p>
<pre><span class=hs-linenum>153: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>e1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ImmExpr</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>154: </span><a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isImm v)}</span><span class='hs-definition'>e1</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-num'>7</span>
<span class=hs-linenum>155: </span>
<span class=hs-linenum>156: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>e2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ImmExpr</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>157: </span><a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isImm v)}</span><span class='hs-definition'>e2</span></a> <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-conid'>Plus</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>e1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>e1</span></span>
</pre>
<p><strong>ANF Expressions</strong></p>
<p>Similiarly, an <code>Expr</code> is in <strong>ANF</strong> if all arguments for operators and applications are <strong>immediate</strong>. Once again, we can formalize this intuition as a Haskell predicate:</p>
<pre><span class=hs-linenum>167: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>isAnf</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>168: </span><span class='hs-definition'>isAnf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>169: </span><a class=annot href="#"><span class=annottext>x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}</span><span class='hs-definition'>isAnf</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>170: </span><span class='hs-definition'>isAnf</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>171: </span><span class='hs-definition'>isAnf</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}</span><span class='hs-varid'>isImm</span></a> <span class='hs-varid'>e1</span> <a class=annot href="#"><span class=annottext>{v : x1:GHC.Types.Bool -&gt; x2:GHC.Types.Bool -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1
                                                                                &amp;&amp; Prop x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}</span><span class='hs-varid'>isImm</span></a> <span class='hs-varid'>e2</span>  <span class='hs-comment'>-- args for operators</span>
<span class=hs-linenum>172: </span><span class='hs-definition'>isAnf</span> <span class='hs-layout'>(</span><span class='hs-conid'>EApp</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}</span><span class='hs-varid'>isImm</span></a> <span class='hs-varid'>e1</span> <a class=annot href="#"><span class=annottext>{v : x1:GHC.Types.Bool -&gt; x2:GHC.Types.Bool -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1
                                                                                &amp;&amp; Prop x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:ANF.Expr -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop (isImm x1)} | v == isImm}</span><span class='hs-varid'>isImm</span></a> <span class='hs-varid'>e2</span>  <span class='hs-comment'>-- must be immediate,</span>
<span class=hs-linenum>173: </span><span class='hs-definition'>isAnf</span> <span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}</span><span class='hs-varid'>isAnf</span></a> <span class='hs-varid'>e1</span> <a class=annot href="#"><span class=annottext>{v : x1:GHC.Types.Bool -&gt; x2:GHC.Types.Bool -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; Prop x1
                                                                                &amp;&amp; Prop x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}</span><span class='hs-varid'>isAnf</span></a> <span class='hs-varid'>e2</span>  <span class='hs-comment'>-- and sub-expressions</span>
<span class=hs-linenum>174: </span><span class='hs-definition'>isAnf</span> <span class='hs-layout'>(</span><span class='hs-conid'>ELam</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:ANF.Expr -&gt; {VV : GHC.Types.Bool | Prop VV &lt;=&gt; Prop (isAnf x1)}</span><span class='hs-varid'>isAnf</span></a> <span class='hs-varid'>e</span>               <span class='hs-comment'>-- must be in ANF</span>
</pre>
<p>and then use the predicate to define the subset of <em>legal</em> ANF expressions:</p>
<pre><span class=hs-linenum>180: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAnf</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>For example, <code>e2</code> above <em>is</em> in ANF but <code>e3</code> is not:</p>
<pre><span class=hs-linenum>186: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>e2'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>187: </span><a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-definition'>e2'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-conid'>Plus</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e1</span>
<span class=hs-linenum>188: </span>
<span class=hs-linenum>189: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>e3</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>190: </span><a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-definition'>e3</span></a> <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-conid'>Plus</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>e2'</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>e2'</span></span>
</pre>
<h2 id="anf-conversion-intuition">ANF Conversion: Intuition</h2>
<p>Now that we have clearly demarcated the territories belonging to plain <code>Expr</code>, immediate <code>ImmExpr</code> and A-Normal <code>AnfExpr</code>, lets see how we can convert the former to the latter.</p>
<p>Recall that our goal is to convert expressions like</p>
<pre><span class=hs-linenum>203: </span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-num'>12</span> <span class='hs-comment'>-</span> <span class='hs-num'>4</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-num'>7</span> <span class='hs-varop'>+</span> <span class='hs-num'>8</span><span class='hs-layout'>)</span>
</pre>
<p>into</p>
<pre><span class=hs-linenum>209: </span><span class='hs-keyword'>let</span> <span class='hs-varid'>anf0</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-num'>3</span>
<span class=hs-linenum>210: </span>    <span class='hs-varid'>anf1</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>12</span> <span class='hs-comment'>-</span> <span class='hs-num'>4</span>
<span class=hs-linenum>211: </span>    <span class='hs-varid'>anf2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anf0</span> <span class='hs-varop'>*</span> <span class='hs-varid'>anf1</span>
<span class=hs-linenum>212: </span>    <span class='hs-varid'>anf3</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>7</span> <span class='hs-varop'>+</span> <span class='hs-num'>8</span>
<span class=hs-linenum>213: </span><span class='hs-keyword'>in</span>
<span class=hs-linenum>214: </span>    <span class='hs-varid'>anf2</span> <span class='hs-varop'>*</span> <span class='hs-varid'>anf3</span>
</pre>
<p>Generalising a bit, we want to convert</p>
<pre><span class=hs-linenum>220: </span><span class='hs-definition'>e1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>e2</span>
</pre>
<p>into</p>
<pre><span class=hs-linenum>226: </span><span class='hs-keyword'>let</span> <span class='hs-varid'>x1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a1</span>  <span class='hs-varop'>...</span> <span class='hs-varid'>xn</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>an</span>
<span class=hs-linenum>227: </span>    <span class='hs-varid'>x1'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a1'</span> <span class='hs-varop'>...</span> <span class='hs-varid'>xm'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>am'</span>
<span class=hs-linenum>228: </span><span class='hs-keyword'>in</span>
<span class=hs-linenum>229: </span>    <span class='hs-varid'>v1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>v2</span>
</pre>
<p>where, <code>v1</code> and <code>v2</code> are immediate, and <code>ai</code> are ANF.</p>
<p><strong>Making Arguments Immediate</strong></p>
<p>In other words, the key requirement is a way to crunch arbitrary <em>argument expressions</em> like <code>e1</code> into <strong>a pair</strong></p>
<pre><span class=hs-linenum>240: </span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span> <span class='hs-varid'>a1</span><span class='hs-layout'>)</span> <span class='hs-varop'>...</span> <span class='hs-layout'>(</span><span class='hs-varid'>xn</span><span class='hs-layout'>,</span> <span class='hs-varid'>an</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>v1</span><span class='hs-layout'>)</span>
</pre>
<p>where</p>
<ol type="1">
<li><code>a1...an</code> are <code>AnfExpr</code>, and</li>
<li><code>v1</code> is an immediate <code>ImmExpr</code></li>
</ol>
<p>such that <code>e1</code> is <em>equivalent</em> to <code>let x1 = a1 ... xn = an in v1</code>. Thus, we need a function</p>
<pre><span class=hs-linenum>252: </span><span class='hs-definition'>imm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ImmExpr</span><span class='hs-layout'>)</span>
</pre>
<p>which we will use to <strong>make arguments immediate</strong> thereby yielding a top level conversion function</p>
<pre><span class=hs-linenum>259: </span><span class='hs-definition'>anf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span>
</pre>
<p>As we need to generate “temporary” intermediate binders, it will be convenient to work within a monad that generates <code>fresh</code> variables:</p>
<pre><span class=hs-linenum>267: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>AnfM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>State</span> <span class='hs-conid'>Int</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>268: </span>
<span class=hs-linenum>269: </span><span class='hs-definition'>fresh</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnfM</span> <span class='hs-conid'>Var</span>
<span class=hs-linenum>270: </span><a class=annot href="#"><span class=annottext>(Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {VV : [GHC.Types.Char] | (len : func(2, [(@(0)  @(1));
                                                                                                                             int])) (VV : [@(0)]) &gt; 0
                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));
                                                                                                                                int])) (VV : [@(0)]) &gt;= 0})</span><span class='hs-definition'>fresh</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>271: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity GHC.Types.Int)</span><span class='hs-varid'>get</span></a>
<span class=hs-linenum>272: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ())</span><span class='hs-varid'>put</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>273: </span>  <a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity [GHC.Types.Char])</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"anf"</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Types.Char]</span><span class='hs-varid'>show</span></a> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
</pre>
<p>Thus, the conversion functions will have the types:</p>
<pre><span class=hs-linenum>279: </span><span class='hs-definition'>anf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-conid'>AnfExpr</span>
<span class=hs-linenum>280: </span><span class='hs-definition'>imm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ImmExpr</span><span class='hs-layout'>)</span>
</pre>
<h2 id="anf-conversion-code">ANF Conversion: Code</h2>
<p>We can now define the top-level conversion thus:</p>
<pre><span class=hs-linenum>289: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>290: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>anf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>291: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>292: </span><a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})</span><span class='hs-definition'>anf</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>293: </span>  <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<span class=hs-linenum>294: </span>
<span class=hs-linenum>295: </span><span class='hs-definition'>anf</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>296: </span>  <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}</span><span class='hs-conid'>EVar</span></a> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class=hs-linenum>297: </span>
<span class=hs-linenum>298: </span><span class='hs-definition'>anf</span> <span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>299: </span>  <a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>a1</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})</span><span class='hs-varid'>anf</span></a> <span class='hs-varid'>e1</span>
<span class=hs-linenum>300: </span>  <a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>a2</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})</span><span class='hs-varid'>anf</span></a> <span class='hs-varid'>e2</span>
<span class=hs-linenum>301: </span>  <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                                       &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isAnf x2)
                                                                                              &amp;&amp; Prop (isAnf x3))} | v == ANF.ELet}</span><span class='hs-conid'>ELet</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>a1</span> <span class='hs-varid'>a2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>302: </span>
<span class=hs-linenum>303: </span><span class='hs-definition'>anf</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-varid'>o</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>304: </span>  <span class='hs-layout'>(</span><span class='hs-varid'>b1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>v1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>imm</span></a> <span class='hs-varid'>e1</span>
<span class=hs-linenum>305: </span>  <span class='hs-layout'>(</span><span class='hs-varid'>b2s</span><span class='hs-layout'>,</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>imm</span></a> <span class='hs-varid'>e2</span>
<span class=hs-linenum>306: </span>  <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>mkLet</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [([GHC.Types.Char], ANF.Expr)] | len v == len b1s + len b2s}</span><span class='hs-varid'>b1s</span></a> <span class='hs-varop'>++</span> <span class='hs-varid'>b2s</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-varid'>o</span> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>307: </span>
<span class=hs-linenum>308: </span><span class='hs-definition'>anf</span> <span class='hs-layout'>(</span><span class='hs-conid'>ELam</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>309: </span>  <a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>a</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})</span><span class='hs-varid'>anf</span></a> <span class='hs-varid'>e</span>
<span class=hs-linenum>310: </span>  <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; x2:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                        &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isAnf x2))} | v == ANF.ELam}</span><span class='hs-conid'>ELam</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>311: </span>
<span class=hs-linenum>312: </span><span class='hs-definition'>anf</span> <span class='hs-layout'>(</span><span class='hs-conid'>EApp</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>313: </span>  <span class='hs-layout'>(</span><span class='hs-varid'>b1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>v1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>imm</span></a> <span class='hs-varid'>e1</span>
<span class=hs-linenum>314: </span>  <span class='hs-layout'>(</span><span class='hs-varid'>b2s</span><span class='hs-layout'>,</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>imm</span></a> <span class='hs-varid'>e2</span>
<span class=hs-linenum>315: </span>  <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ANF.Expr)</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>mkLet</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [([GHC.Types.Char], ANF.Expr)] | len v == len b1s + len b2s}</span><span class='hs-varid'>b1s</span></a> <span class='hs-varop'>++</span> <span class='hs-varid'>b2s</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:ANF.Expr -&gt; x2:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                   &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x1)
                                                                          &amp;&amp; Prop (isImm x2))} | v == ANF.EApp}</span><span class='hs-conid'>EApp</span></a> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>In <code>anf</code> the real work happens inside <code>imm</code> which takes an arbitary <em>argument</em> expression and makes it <strong>immediate</strong> by generating temporary (ANF) bindings. The resulting bindings (and immediate values) are composed by the helper <code>mkLet</code> that takes a list of binders and a body <code>AnfExpr</code> and stitches them into a single <code>AnfExpr</code>:</p>
<pre><span class=hs-linenum>325: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mkLet</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>326: </span><a class=annot href="#"><span class=annottext>[([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-definition'>mkLet</span></a> <span class='hs-conid'>[]</span>         <a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>e'</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e'</span>
<span class=hs-linenum>327: </span><span class='hs-definition'>mkLet</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                                       &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isAnf x2)
                                                                                              &amp;&amp; Prop (isAnf x3))} | v == ANF.ELet}</span><span class='hs-conid'>ELet</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})] -&gt; {v : ANF.Expr | Prop (isAnf v)} -&gt; {v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>mkLet</span></a> <span class='hs-varid'>bs</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
</pre>
<p>The arguments are made immediate by <code>imm</code> defined as:</p>
<pre><span class=hs-linenum>333: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>334: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>imm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ImmExpr</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>335: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>336: </span><a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-definition'>imm</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                      &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EInt}</span><span class='hs-conid'>EInt</span></a> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<span class=hs-linenum>337: </span><span class='hs-definition'>imm</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}</span><span class='hs-conid'>EVar</span></a> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class=hs-linenum>338: </span><span class='hs-definition'>imm</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>immExpr</span></a> <span class='hs-varid'>e</span>
<span class=hs-linenum>339: </span><span class='hs-definition'>imm</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ELam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>immExpr</span></a> <span class='hs-varid'>e</span>
<span class=hs-linenum>340: </span><span class='hs-definition'>imm</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-varid'>o</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; ANF.Expr -&gt; (x4:{VV : ANF.Expr | VV /= ANF.srcExpr
                                             &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                             GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x5:{VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                                                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                             bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                        GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x5
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e2
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x4
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e1}) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ({VV : [([GHC.Types.Char], {VV : ANF.Expr | ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)})] | (len : func(2, [(@(0)  @(1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             int])) (VV : [@(0)]) &gt; 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int])) (VV : [@(0)]) &gt;= 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (VV : @(43)) == ((fst : func(0, [(Tuple  @(43)  @(44));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @(43)])) (VV : (Tuple  @(45)  @(44))) : @(43))}, {VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (VV : @(42)) == ((snd : func(0, [(Tuple  @(45)  @(42));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       @(42)])) (VV : (Tuple  @(45)  @(44))) : @(42))}))</span><span class='hs-varid'>imm2</span></a> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : ANF.Op -&gt; x2:ANF.Expr -&gt; x3:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                             &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x2)
                                                                                    &amp;&amp; Prop (isImm x3))} | v == ANF.EBin}</span><span class='hs-conid'>EBin</span></a> <span class='hs-varid'>o</span><span class='hs-layout'>)</span>
<span class=hs-linenum>341: </span><span class='hs-definition'>imm</span> <span class='hs-layout'>(</span><span class='hs-conid'>EApp</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; ANF.Expr -&gt; (x4:{VV : ANF.Expr | VV /= ANF.srcExpr
                                             &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                             GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x5:{VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                                                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                             bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                        GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x5
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e2
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x4
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e1}) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ({VV : [([GHC.Types.Char], {VV : ANF.Expr | ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)})] | (len : func(2, [(@(0)  @(1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             int])) (VV : [@(0)]) &gt; 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int])) (VV : [@(0)]) &gt;= 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (VV : @(43)) == ((fst : func(0, [(Tuple  @(43)  @(44));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @(43)])) (VV : (Tuple  @(45)  @(44))) : @(43))}, {VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (VV : @(42)) == ((snd : func(0, [(Tuple  @(45)  @(42));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       @(42)])) (VV : (Tuple  @(45)  @(44))) : @(42))}))</span><span class='hs-varid'>imm2</span></a> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span> <a class=annot href="#"><span class=annottext>{v : x1:ANF.Expr -&gt; x2:ANF.Expr -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; false)
                                                   &amp;&amp; (Prop (isAnf v) &lt;=&gt; Prop (isImm x1)
                                                                          &amp;&amp; Prop (isImm x2))} | v == ANF.EApp}</span><span class='hs-conid'>EApp</span></a>
</pre>
<ul>
<li><p>Numbers and variables are already immediate, and are returned directly.</p></li>
<li><p>Let-binders and lambdas are simply converted to ANF, and assigned to a fresh binder:</p></li>
</ul>
<pre><span class=hs-linenum>350: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>immExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ImmExpr</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>351: </span><a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-definition'>immExpr</span></a> <a class=annot href="#"><span class=annottext>ANF.Expr</span><span class='hs-varid'>e</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>352: </span>  <a class=annot href="#"><span class=annottext>{v : ANF.Expr | Prop (isAnf v)}</span><span class='hs-varid'>a</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})</span><span class='hs-varid'>anf</span></a> <span class='hs-varid'>e</span>
<span class=hs-linenum>353: </span>  <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | (len : func(2, [(@(0)  @(1));
                                        int])) (v : [@(0)]) &gt; 0
                        &amp;&amp; (len : func(2, [(@(0)  @(1)); int])) (v : [@(0)]) &gt;= 0}</span><span class='hs-varid'>t</span></a> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fresh</span>
<span class=hs-linenum>354: </span>  <a class=annot href="#"><span class=annottext>([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))</span><span class='hs-varid'>return</span></a> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}</span><span class='hs-conid'>EVar</span></a> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
</pre>
<ul>
<li>Finally, binary operators and applications are converted by <code>imm2</code> that takes two arbitrary expressions and an expression constructor, yielding the anf-binders and immediate expression.</li>
</ul>
<pre><span class=hs-linenum>362: </span><span class='hs-definition'>imm2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ImmExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ImmExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span>
<span class=hs-linenum>363: </span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnfExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ImmExpr</span><span class='hs-layout'>)</span>
<span class=hs-linenum>364: </span><a class=annot href="#"><span class=annottext>ANF.Expr -&gt; ANF.Expr -&gt; (x4:{VV : ANF.Expr | VV /= ANF.srcExpr
                                             &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                             GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x5:{VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                                                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                             bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                        GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x5 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (x4 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                     bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x5
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e2
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= x4
                                                                                                                                                                                                                                                                                                &amp;&amp; VV /= ANF.e1}) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ({VV : [([GHC.Types.Char], {VV : ANF.Expr | ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                     &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)})] | (len : func(2, [(@(0)  @(1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             int])) (VV : [@(0)]) &gt; 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (len : func(2, [(@(0)  @(1));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int])) (VV : [@(0)]) &gt;= 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; (VV : @(43)) == ((fst : func(0, [(Tuple  @(43)  @(44));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @(43)])) (VV : (Tuple  @(45)  @(44))) : @(43))}, {VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp; (VV : @(42)) == ((snd : func(0, [(Tuple  @(45)  @(42));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       @(42)])) (VV : (Tuple  @(45)  @(44))) : @(42))}))</span><span class='hs-definition'>imm2</span></a> <a class=annot href="#"><span class=annottext>ANF.Expr</span><span class='hs-varid'>e1</span></a> <a class=annot href="#"><span class=annottext>ANF.Expr</span><span class='hs-varid'>e2</span></a> <a class=annot href="#"><span class=annottext>x1:{VV : ANF.Expr | VV /= ANF.srcExpr
                    &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                         bool])) ((isImm : func(0, [ANF.Expr;
                                                                    GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                    &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                        bool])) ((isImm : func(0, [ANF.Expr;
                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; x2:{VV : ANF.Expr | VV /= ANF.srcExpr
                                                                                                                                               &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                    bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                               GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                              GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)} -&gt; {VV : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                   bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                              GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (VV : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                           GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; VV /= x2
                                                                                                                                                                                                                                                                       &amp;&amp; VV /= ANF.e2
                                                                                                                                                                                                                                                                       &amp;&amp; VV /= x1
                                                                                                                                                                                                                                                                       &amp;&amp; VV /= ANF.e1}</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>365: </span>  <span class='hs-layout'>(</span><span class='hs-varid'>b1s</span><span class='hs-layout'>,</span> <span class='hs-varid'>v1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>imm</span></a> <span class='hs-varid'>e1</span>
<span class=hs-linenum>366: </span>  <span class='hs-layout'>(</span><span class='hs-varid'>b2s</span><span class='hs-layout'>,</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], {v : ANF.Expr | Prop (isAnf v)})], {v : ANF.Expr | Prop (isImm v)}))</span><span class='hs-varid'>imm</span></a> <span class='hs-varid'>e2</span>
<span class=hs-linenum>367: </span>  <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | (len : func(2, [(@(0)  @(1));
                                        int])) (v : [@(0)]) &gt; 0
                        &amp;&amp; (len : func(2, [(@(0)  @(1)); int])) (v : [@(0)]) &gt;= 0}</span><span class='hs-varid'>t</span></a>         <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fresh</span>
<span class=hs-linenum>368: </span>  <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>[([GHC.Types.Char], ANF.Expr)]</span><span class='hs-varid'>bs'</span></a>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[([GHC.Types.Char], ANF.Expr)]</span><span class='hs-varid'>b1s</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>[([GHC.Types.Char], ANF.Expr)]</span><span class='hs-varid'>b2s</span></a> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : ANF.Expr | v /= ANF.srcExpr
                        &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                             bool])) ((isImm : func(0, [ANF.Expr;
                                                                        GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                        &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool)} -&gt; x2:{v : ANF.Expr | v /= ANF.srcExpr
                                                                                                                                                 &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                      bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                 GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                 &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                     bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool)} -&gt; {v : ANF.Expr | (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                        bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                   GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; false)
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e2 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (x1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool)
                                                                                                                                                                                                                                                                                                                                                                              &amp;&amp; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                                  bool])) ((isImm : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                             GHC.Types.Bool])) (ANF.e1 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; true)
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e3 : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; ((Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                            bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                       GHC.Types.Bool])) (v : ANF.Expr) : GHC.Types.Bool) &lt;=&gt; (Prop : func(0, [GHC.Types.Bool;
                                                                                                                                                                                                                                                                                                                                                                                               bool])) ((isAnf : func(0, [ANF.Expr;
                                                                                                                                                                                                                                                                                                                                                                                                                          GHC.Types.Bool])) (ANF.e2' : ANF.Expr) : GHC.Types.Bool))
                                                                                                                                                                                                                                                                       &amp;&amp; v /= x2
                                                                                                                                                                                                                                                                       &amp;&amp; v /= ANF.e2
                                                                                                                                                                                                                                                                       &amp;&amp; v /= x1
                                                                                                                                                                                                                                                                       &amp;&amp; v /= ANF.e1} | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>369: </span>  <a class=annot href="#"><span class=annottext>([([GHC.Types.Char], ANF.Expr)], ANF.Expr) -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity ([([GHC.Types.Char], ANF.Expr)], ANF.Expr))</span><span class='hs-varid'>return</span></a>      <span class='hs-layout'>(</span><span class='hs-varid'>bs'</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] -&gt; {v : ANF.Expr | (Prop (isImm v) &lt;=&gt; true)
                                         &amp;&amp; (Prop (isAnf v) &lt;=&gt; true)} | v == ANF.EVar}</span><span class='hs-conid'>EVar</span></a> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
</pre>
<p>You can run it thus:</p>
<pre><span class=hs-linenum>376: </span><span class='hs-definition'>toAnf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnfExpr</span>
<span class=hs-linenum>377: </span><a class=annot href="#"><span class=annottext>ANF.Expr -&gt; ANF.Expr</span><span class='hs-definition'>toAnf</span></a> <a class=annot href="#"><span class=annottext>ANF.Expr</span><span class='hs-varid'>e</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ANF.Expr</span><span class='hs-varid'>evalState</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>ANF.Expr -&gt; (Control.Monad.Trans.State.Lazy.StateT GHC.Types.Int Data.Functor.Identity.Identity {v : ANF.Expr | Prop (isAnf v)})</span><span class='hs-varid'>anf</span></a> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span>
</pre>
<pre><span class=hs-linenum>381: </span><span class='hs-definition'>ghci</span><span class='hs-varop'>&gt;</span> <span class='hs-varid'>toAnf</span> <span class='hs-varid'>srcExpr</span>
<span class=hs-linenum>382: </span><span class='hs-conid'>ELet</span> <span class='hs-str'>"anf0"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-conid'>Plus</span> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>383: </span> <span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-str'>"anf1"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-conid'>Minus</span> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-num'>12</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-num'>4</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>384: </span>   <span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-str'>"anf2"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-conid'>Times</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-str'>"anf0"</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-str'>"anf1"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>385: </span>     <span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-str'>"anf3"</span> <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-conid'>Plus</span> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-num'>7</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EInt</span> <span class='hs-num'>8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>386: </span>       <span class='hs-layout'>(</span><span class='hs-conid'>EBin</span> <span class='hs-conid'>Times</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-str'>"anf2"</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-str'>"anf3"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre>
<p>which, can be pretty-printed to yield exactly the outcome desired at the top:</p>
<pre><span class=hs-linenum>392: </span><span class='hs-keyword'>let</span> <span class='hs-varid'>anf0</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-num'>3</span>
<span class=hs-linenum>393: </span>    <span class='hs-varid'>anf1</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>12</span> <span class='hs-comment'>-</span> <span class='hs-num'>4</span>
<span class=hs-linenum>394: </span>    <span class='hs-varid'>anf2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anf0</span> <span class='hs-varop'>*</span> <span class='hs-varid'>anf1</span>
<span class=hs-linenum>395: </span>    <span class='hs-varid'>anf3</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>7</span> <span class='hs-varop'>+</span> <span class='hs-num'>8</span>
<span class=hs-linenum>396: </span><span class='hs-keyword'>in</span>
<span class=hs-linenum>397: </span>    <span class='hs-varid'>anf2</span> <span class='hs-varop'>*</span> <span class='hs-varid'>anf3</span>
</pre>
<p>There! The refinements make this tricky conversion quite straightforward and natural, without requiring us to duplicate types and code. As an exercise, can you use refinements to:</p>
<ol type="1">
<li>Port the classic <a href="http://matt.might.net/articles/a-normalization/">continuation-based conversion ?</a></li>
<li>Check that the conversion yields <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/10-case-study-associative-maps.html#/using-maps-well-scoped-expressions">well-scoped terms ?</a></li>
</ol>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/01/normal-forms.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/09/01/normal-forms.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Okasaki's Lazy Queues</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2015/01/30/okasakis-lazy-queue.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2015/01/30/okasakis-lazy-queue.lhs</id>
    <published>true</published>
    <updated>2015-01-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Okasaki's Lazy Queues</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Jan 28, 2015
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a href="/tags/measures.html">measures</a>
              
            </div>

            <br>
			            <p>The “Hello World!” example for fancy type systems is probably the sized vector or list <code>append</code> function (“The output has size equal to the <em>sum</em> of the inputs!”). One the one hand, it is perfect: simple enough to explain without pages of code, yet complex enough to show off whats cool about dependency. On the other hand, like the sweater I’m sporting right now, it’s a bit well-worn and worse, was never wholly convincing (“Why do I <em>care</em> what the <em>size</em> of the output list is anyway?”)</p>
<p>Recently, I came across a nice example that is almost as simple, but is also well motivated: Okasaki’s beautiful <a href="http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf">Lazy Amortized Queues</a>. This structure leans heavily on an invariant to provide fast <em>insertion</em> and <em>deletion</em>. Let’s see how to enforce that invariant with LiquidHaskell.</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>30: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>31: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--total"</span>          <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>32: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--maxparams=3"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>33: </span>
<span class=hs-linenum>34: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>LazyQueue</span> <span class='hs-layout'>(</span><span class='hs-conid'>Queue</span><span class='hs-layout'>,</span> <span class='hs-varid'>insert</span><span class='hs-layout'>,</span> <span class='hs-varid'>remove</span><span class='hs-layout'>,</span> <span class='hs-varid'>emp</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>35: </span>
<span class=hs-linenum>36: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span><span class='hs-layout'>)</span>
<span class=hs-linenum>37: </span>
<span class=hs-linenum>38: </span><span class='hs-comment'>-- | Size function actually returns the size: (Duh!)</span>
<span class=hs-linenum>39: </span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>q</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| v = size q}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>41: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Queue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Q</span>  <span class='hs-layout'>{</span> <a class=annot href="#"><span class=annottext>forall a. (LazyQueue.Queue a) -&gt; (LazyQueue.SList a)</span><span class='hs-varid'>front</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>42: </span>                  <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall a. (LazyQueue.Queue a) -&gt; (LazyQueue.SList a)</span><span class='hs-varid'>back</span></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>43: </span>                  <span class='hs-layout'>}</span>
<span class=hs-linenum>44: </span>
<span class=hs-linenum>45: </span><span class='hs-comment'>-- Source: Okasaki, JFP 1995</span>
<span class=hs-linenum>46: </span><span class='hs-comment'>-- <a href="http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf">http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf</a></span>
<span class=hs-linenum>47: </span>
</pre>
</div>
<h2 id="queues">Queues</h2>
<p>A <a href="http://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">queue</a> is a structure into which we can <code>insert</code> and <code>remove</code> data such that the order in which the data is removed is the same as the order in which it was inserted.</p>
<figure>
<img src="/static/img/queue.png" alt="A Queue" /><figcaption>A Queue</figcaption>
</figure>
<p>To implement a queue <em>efficiently</em> one needs to have rapid access to both the “head” as well as the “tail” because we <code>remove</code> elements from former and <code>insert</code> elements into the latter. This is quite straightforward with explicit pointers and mutation – one uses an old school linked list and maintains pointers to the head and the tail. But can we implement the structure efficiently without having stoop so low?</p>
<h2 id="queues-pair-of-lists">Queues = Pair of Lists</h2>
<p>Almost two decades ago, Chris Okasaki came up with a very cunning way to implement queues using a <em>pair</em> of lists – let’s call them <code>front</code> and <code>back</code> which represent the corresponding parts of the Queue.</p>
<ul>
<li>To <code>insert</code> elements, we just <em>cons</em> them onto the <code>back</code> list,</li>
<li>To <code>remove</code> elements, we just <em>un-cons</em> them from the <code>front</code> list.</li>
</ul>
<figure>
<img src="/static/img/queue-lists.png" alt="A Queue is Two Lists" /><figcaption>A Queue is Two Lists</figcaption>
</figure>
<p>The catch is that we need to shunt elements from the back to the front every so often, e.g. when</p>
<ol type="1">
<li>a <code>remove</code> call is triggered, and</li>
<li>the <code>front</code> list is empty,</li>
</ol>
<p>We can transfer the elements from the <code>back</code> to the <code>front</code>.</p>
<figure>
<img src="/static/img/queue-rotate.png" alt="Transferring Elements from Back to Front" /><figcaption>Transferring Elements from Back to Front</figcaption>
</figure>
<p>Okasaki observed that every element is only moved <em>once</em> from the front to the back; hence, the time for <code>insert</code> and <code>lookup</code> could be <code>O(1)</code> when <em>amortized</em> over all the operations. Awesome, right?!</p>
<p>Almost. Some set of unlucky <code>remove</code> calls (which occur when the <code>front</code> is empty) are stuck paying the bill. They have a rather high latency up to <code>O(n)</code> where <code>n</code> is the total number of operations. Oops.</p>
<h2 id="queue-balanced-lazy-lists">Queue = Balanced Lazy Lists</h2>
<p>This is where Okasaki’s beautiful insights kick in. Okasaki observed that all we need to do is to enforce a simple invariant:</p>
<p><strong>Invariant:</strong> Size of <code>front</code> &gt;= Size of <code>back</code></p>
<p>Now, if the lists are <em>lazy</em> i.e. only constructed as the head value is demanded, then a single <code>remove</code> needs only a tiny <code>O(log n)</code> in the worst case, and so no single <code>remove</code> is stuck paying the bill.</p>
<p>Let’s see how to represent these Queues and ensure the crucial invariant(s) with LiquidHaskell. What we need are the following ingredients:</p>
<ol type="1">
<li><p>A type for <code>List</code>s, and a way to track their <code>size</code>,</p></li>
<li><p>A type for <code>Queue</code>s which encodes the <em>balance</em> invariant – ``front longer than back",</p></li>
<li><p>A way to implement the <code>insert</code>, <code>remove</code> and <code>transfer</code> operations.</p></li>
</ol>
<h2 id="sized-lists">Sized Lists</h2>
<p>The first part is super easy. Let’s define a type:</p>
<pre><span class=hs-linenum>127: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SL</span> <span class='hs-layout'>{</span> <a class=annot href="#"><span class=annottext>forall a.
x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>forall a. (LazyQueue.SList a) -&gt; [a]</span><span class='hs-varid'>elems</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>}</span>
</pre>
<p>We have a special field that saves the <code>size</code> because otherwise, we have a linear time computation that wrecks Okasaki’s careful analysis. (Actually, he presents a variant which does <em>not</em> require saving the size as well, but that’s for another day.)</p>
<p>But how can we be sure that <code>size</code> is indeed the <em>real size</em> of <code>elems</code>?</p>
<p>Let’s write a function to <em>measure</em> the real size:</p>
<pre><span class=hs-linenum>140: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>realSize</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>141: </span><span class='hs-definition'>realSize</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>142: </span><a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {VV : GHC.Types.Int | VV == realSize x1}</span><span class='hs-definition'>realSize</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:GHC.Prim.Int# -&gt; {v : GHC.Types.Int | v == (x1  :  int)}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>143: </span><span class='hs-definition'>realSize</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>forall a. x1:[a] -&gt; {VV : GHC.Types.Int | VV == realSize x1}</span><span class='hs-varid'>realSize</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>and now, we can simply specify a <em>refined</em> type for <code>SList</code> that ensures that the <em>real</em> size is saved in the <code>size</code> field:</p>
<pre><span class=hs-linenum>150: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SL</span> <span class='hs-layout'>{</span>
<span class=hs-linenum>151: </span>       <span class='hs-varid'>size</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span> 
<span class=hs-linenum>152: </span>     <span class='hs-layout'>,</span> <span class='hs-varid'>elems</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>realSize</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span><span class='hs-layout'>}</span>
<span class=hs-linenum>153: </span>     <span class='hs-layout'>}</span>
<span class=hs-linenum>154: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>As a sanity check, consider this:</p>
<pre><span class=hs-linenum>160: </span><a class=annot href="#"><span class=annottext>{VV : (LazyQueue.SList {VV : [GHC.Types.Char] | len VV &gt;= 0}) | size VV &gt; 0}</span><span class='hs-definition'>okList</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [{v : [GHC.Types.Char] | len v &gt;= 0}] | realSize v == x1}
-&gt; {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | elems v == x2 &amp;&amp; size v == x1}</span><span class='hs-conid'>SL</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : [GHC.Types.Char] | len v &gt;= 0}]&lt;\_ VV -&gt; false&gt; | null v &lt;=&gt; false &amp;&amp; len v &gt;= 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-str'>"cat"</span></a><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- accepted</span>
<span class=hs-linenum>161: </span>
<span class=hs-linenum>162: </span><a class=annot href="#"><span class=annottext>forall a. (LazyQueue.SList a)</span><span class='hs-definition'>badList</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class='hs-conid'>SL</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [a] | null v &lt;=&gt; true &amp;&amp; realSize v == 0 &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}</span><span class='hs-conid'>[]</span></a></span>         <span class='hs-comment'>-- rejected</span>
</pre>
<p>It is helpful to define a few aliases for <code>SList</code>s of a size <code>N</code> and non-empty <code>SList</code>s:</p>
<pre><span class=hs-linenum>169: </span><span class='hs-comment'>-- | SList of size N</span>
<span class=hs-linenum>170: </span>
<span class=hs-linenum>171: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>SListN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>size</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>172: </span>
<span class=hs-linenum>173: </span><span class='hs-comment'>-- | Non-Empty SLists:</span>
<span class=hs-linenum>174: </span>
<span class=hs-linenum>175: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>size</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>176: </span>
</pre>
<p>Finally, we can define a basic API for <code>SList</code>.</p>
<p><strong>To Construct</strong> lists, we use <code>nil</code> and <code>cons</code>:</p>
<pre><span class=hs-linenum>184: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>nil</span>          <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SListN</span> <span class='hs-varid'>a</span> <span class='hs-num'>0</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>185: </span><a class=annot href="#"><span class=annottext>forall a. {v : (LazyQueue.SList a) | size v == 0}</span><span class='hs-definition'>nil</span></a>              <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class='hs-conid'>SL</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (0  :  int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | null v &lt;=&gt; true &amp;&amp; realSize v == 0 &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>186: </span>
<span class=hs-linenum>187: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>cons</span>         <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SListN</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>{size xs + 1}</span>   <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a.
a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x2 + 1}</span><span class='hs-definition'>cons</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>SL</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class='hs-conid'>SL</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>n</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><a class=annot href="#"><span class=annottext>x1:a
-&gt; x2:[a]
-&gt; {v : [a] | null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; realSize v == 1 + realSize x2 &amp;&amp; xsListSelector v == x2 &amp;&amp; len v == 1 + len x2}</span><span class='hs-conop'>:</span></a><a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; realSize v == n &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
</pre>
<p><strong>To Destruct</strong> lists, we have <code>hd</code> and <code>tl</code>.</p>
<pre><span class=hs-linenum>194: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>tl</span>           <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SListN</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>{size xs - 1}</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>195: </span><a class=annot href="#"><span class=annottext>forall a.
x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class='hs-definition'>tl</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>SL</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class='hs-conid'>SL</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>n</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1  :  int)}</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>196: </span>
<span class=hs-linenum>197: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>hd</span>           <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>198: </span><a class=annot href="#"><span class=annottext>forall a. {v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class='hs-definition'>hd</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>SL</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> 
</pre>
<p>Don’t worry, they are perfectly <em>safe</em> as LiquidHaskell will make sure we <em>only</em> call these operators on non-empty <code>SList</code>s. For example,</p>
<pre><span class=hs-linenum>205: </span><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-definition'>okHd</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}
-&gt; {v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-varid'>hd</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class='hs-varid'>okList</span></a>       <span class='hs-comment'>-- accepted</span>
<span class=hs-linenum>206: </span>
<span class=hs-linenum>207: </span><a class=annot href="#"><span class=annottext>{VV : [GHC.Types.Char] | len VV &gt;= 0}</span><span class='hs-definition'>badHd</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}
-&gt; {v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-varid'>hd</span></a> <span class='hs-layout'>(</span><span class=hs-error><a class=annot href="#"><span class=annottext>x1:{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v == size x1 - 1}</span><span class='hs-varid'>tl</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class='hs-varid'>okList</span></a></span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- rejected</span>
</pre>
<h2 id="queue-type">Queue Type</h2>
<p>Now, it is quite straightforward to define the <code>Queue</code> type, as a pair of lists, <code>front</code> and <code>back</code>, such that the latter is always smaller than the former:</p>
<pre><span class=hs-linenum>218: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Queue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Q</span> <span class='hs-layout'>{</span>
<span class=hs-linenum>219: </span>       <span class='hs-varid'>front</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>220: </span>     <span class='hs-layout'>,</span> <span class='hs-varid'>back</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SListLE</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>size</span> <span class='hs-varid'>front</span><span class='hs-layout'>)</span>
<span class=hs-linenum>221: </span>     <span class='hs-layout'>}</span>
<span class=hs-linenum>222: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>Where the alias <code>SListLE a L</code> corresponds to lists with less than <code>N</code> elements:</p>
<pre><span class=hs-linenum>228: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>SListLE</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>size</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;=</span> <span class='hs-conid'>N</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>As a quick check, notice that we <em>cannot represent illegal Queues</em>:</p>
<pre><span class=hs-linenum>234: </span><a class=annot href="#"><span class=annottext>{VV : (LazyQueue.Queue [GHC.Types.Char]) | 0 &lt; qsize VV}</span><span class='hs-definition'>okQ</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList [GHC.Types.Char])
-&gt; x2:{v : (LazyQueue.SList [GHC.Types.Char]) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue [GHC.Types.Char]) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class='hs-conid'>Q</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class='hs-varid'>okList</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList [GHC.Types.Char]) | size v == 0}</span><span class='hs-varid'>nil</span></a>  <span class='hs-comment'>-- accepted, |front| &gt; |back| </span>
<span class=hs-linenum>235: </span>
<span class=hs-linenum>236: </span><a class=annot href="#"><span class=annottext>{VV : (LazyQueue.Queue [GHC.Types.Char]) | 0 &lt; qsize VV}</span><span class='hs-definition'>badQ</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList [GHC.Types.Char])
-&gt; x2:{v : (LazyQueue.SList [GHC.Types.Char]) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue [GHC.Types.Char]) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class='hs-conid'>Q</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList [GHC.Types.Char]) | size v == 0}</span><span class='hs-varid'>nil</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class='hs-varid'>okList</span></a></span>  <span class='hs-comment'>-- rejected, |front| &lt; |back|</span>
</pre>
<p><strong>To Measure Queue Size</strong> let us define a function</p>
<pre><span class=hs-linenum>242: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>qsize</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>243: </span><span class='hs-definition'>qsize</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Queue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>244: </span><a class=annot href="#"><span class=annottext>forall a.
x1:(LazyQueue.Queue a) -&gt; {VV : GHC.Types.Int | VV == qsize x1}</span><span class='hs-definition'>qsize</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Q</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == r &amp;&amp; size v &lt;= size l}</span><span class='hs-varid'>r</span></a>
</pre>
<p>This will prove helpful to define <code>Queue</code>s of a given size <code>N</code> and non-empty <code>Queue</code>s (from which values can be safely removed.)</p>
<pre><span class=hs-linenum>251: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>QueueN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Queue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>qsize</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>252: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NEQueue</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Queue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>qsize</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<h2 id="queue-operations">Queue Operations</h2>
<p>Almost there! Now all that remains is to define the <code>Queue</code> API. The code below is more or less identical to Okasaki’s (I prefer <code>front</code> and <code>back</code> to his <code>left</code> and <code>right</code>.)</p>
<p><strong>The Empty Queue</strong> is simply one where both <code>front</code> and <code>back</code> are <code>nil</code>.</p>
<pre><span class=hs-linenum>267: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>emp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>QueueN</span> <span class='hs-varid'>a</span> <span class='hs-num'>0</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>268: </span><a class=annot href="#"><span class=annottext>forall a. {v : (LazyQueue.Queue a) | 0 == qsize v}</span><span class='hs-definition'>emp</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class='hs-conid'>Q</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v == 0}</span><span class='hs-varid'>nil</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v == 0}</span><span class='hs-varid'>nil</span></a>
</pre>
<p><strong>To Insert</strong> an element we just <code>cons</code> it to the <code>back</code> list, and call the <em>smart constructor</em> <code>makeq</code> to ensure that the balance invariant holds:</p>
<pre><span class=hs-linenum>275: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>insert</span>       <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>q</span><span class='hs-conop'>:</span><span class='hs-conid'>Queue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>QueueN</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>{qsize q + 1}</span>   <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>276: </span><a class=annot href="#"><span class=annottext>forall a.
a
-&gt; x2:(LazyQueue.Queue a)
-&gt; {v : (LazyQueue.Queue a) | qsize x2 + 1 == qsize v}</span><span class='hs-definition'>insert</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>e</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Q</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}
-&gt; {v : (LazyQueue.Queue a) | size x1 + size v == qsize v}</span><span class='hs-varid'>makeq</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : a | VV == e}</span><span class='hs-varid'>e</span></a> <a class=annot href="#"><span class=annottext>a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class='hs-varop'>`cons`</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f}</span><span class='hs-varid'>b</span></a><span class='hs-layout'>)</span>
</pre>
<p><strong>To Remove</strong> an element we pop it off the <code>front</code> by using <code>hd</code> and <code>tl</code>. Notice that the <code>remove</code> is only called on non-empty <code>Queue</code>s, which together with the key balance invariant, ensures that the calls to <code>hd</code> and <code>tl</code> are safe.</p>
<pre><span class=hs-linenum>284: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>remove</span>       <span class='hs-keyglyph'>::</span> <span class='hs-varid'>q</span><span class='hs-conop'>:</span><span class='hs-conid'>NEQueue</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>QueueN</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>{qsize q - 1}</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>285: </span><a class=annot href="#"><span class=annottext>forall a.
x1:{v : (LazyQueue.Queue a) | 0 &lt; qsize v}
-&gt; (a, {v : (LazyQueue.Queue a) | qsize x1 - 1 == qsize v})</span><span class='hs-definition'>remove</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Q</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b &lt;p2 :: a b -&gt; Prop&gt;.
x1:a
-&gt; x2:{VV : b&lt;p2 x1&gt; | true}
-&gt; {v : (a, b)&lt;\x6 VV -&gt; p2 x6&gt; | fst v == x1 &amp;&amp; x_Tuple22 v == x2 &amp;&amp; snd v == x2 &amp;&amp; x_Tuple21 v == x1}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class='hs-varid'>hd</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}
-&gt; {v : (LazyQueue.Queue a) | size x1 + size v == qsize v}</span><span class='hs-varid'>makeq</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class='hs-varid'>tl</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f}</span><span class='hs-varid'>b</span></a><span class='hs-layout'>)</span>
</pre>
<p><em>Aside:</em> Why didn’t we (or Okasaki) use a pattern match here?</p>
<p><strong>To Ensure the Invariant</strong> we use the smart constructor <code>makeq</code>, which is where the heavy lifting, such as it is, happens. The constructor takes two lists, the front <code>f</code> and back <code>b</code> and if they are balanced, directly returns the <code>Queue</code>, and otherwise transfers the elements from <code>b</code> over using <code>rot</code>ate.</p>
<pre><span class=hs-linenum>297: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>makeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>298: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-conid'>SListLE</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>{size f + 1 }</span>
<span class=hs-linenum>299: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>QueueN</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>{size f + size b}</span>
<span class=hs-linenum>300: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>301: </span><a class=annot href="#"><span class=annottext>forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}
-&gt; {v : (LazyQueue.Queue a) | size x1 + size x2 == qsize v}</span><span class='hs-definition'>makeq</span></a> <a class=annot href="#"><span class=annottext>(LazyQueue.SList a)</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v &lt;= size f + 1}</span><span class='hs-varid'>b</span></a> 
<span class=hs-linenum>302: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt;= v}</span><span class='hs-varop'>&lt;=</span></a> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class='hs-conid'>Q</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum>303: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class='hs-conid'>Q</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}
-&gt; x3:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}</span><span class='hs-varid'>rot</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v == 0}</span><span class='hs-varid'>nil</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v == 0}</span><span class='hs-varid'>nil</span></a>
</pre>
<p><strong>The Rotate</strong> function is only called when the <code>back</code> is one larger than the <code>front</code> (we never let things drift beyond that). It is arranged so that it the <code>hd</code> is built up fast, before the entire computation finishes; which, combined with laziness provides the efficient worst-case guarantee.</p>
<pre><span class=hs-linenum>313: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>rot</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>314: </span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-conid'>SListN</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>{1 + size f}</span>
<span class=hs-linenum>315: </span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-conid'>SList</span> <span class='hs-keyword'>_</span>
<span class=hs-linenum>316: </span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SListN</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>{size f + size b + size a}</span>
<span class=hs-linenum>317: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>318: </span><a class=annot href="#"><span class=annottext>forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}
-&gt; x3:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}</span><span class='hs-definition'>rot</span></a> <a class=annot href="#"><span class=annottext>(LazyQueue.SList a)</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v == 1 + size f}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>(LazyQueue.SList a)</span><span class='hs-varid'>a</span></a>
<span class=hs-linenum>319: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (0  :  int)}</span><span class='hs-num'>0</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class='hs-varid'>hd</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class='hs-varop'>`cons`</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == a}</span><span class='hs-varid'>a</span></a>
<span class=hs-linenum>320: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class='hs-varid'>hd</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class='hs-varop'>`cons`</span></a> <a class=annot href="#"><span class=annottext>forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}
-&gt; x3:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}</span><span class='hs-varid'>rot</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class='hs-varid'>tl</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == f}</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class='hs-varid'>tl</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}</span><span class='hs-varid'>b</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class='hs-varid'>hd</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class='hs-varop'>`cons`</span></a> <a class=annot href="#"><span class=annottext>{v : (LazyQueue.SList a) | v == a}</span><span class='hs-varid'>a</span></a><span class='hs-layout'>)</span>
</pre>
<h2 id="conclusion">Conclusion</h2>
<p>Well there you have it; Okasaki’s beautiful lazy Queue, with the invariants easily expressed and checked with LiquidHaskell. I find this example particularly interesting because the refinements express invariants that are critical for efficiency, and furthermore the code introspects on the <code>size</code> in order to guarantee the invariants. Plus, it’s just marginally more complicated than <code>append</code> and so, (I hope!) was easy to follow.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2015/01/30/okasakis-lazy-queue.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2015/01/30/okasakis-lazy-queue.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>

</feed>
